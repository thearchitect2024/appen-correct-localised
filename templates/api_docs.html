<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AppenCorrect API Documentation</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f8f9fa;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px 0;
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            margin: 0;
            font-size: 2.5em;
        }
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        .nav {
            background: white;
            padding: 15px 0;
            margin-bottom: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
        }
        .nav a {
            color: #667eea;
            text-decoration: none;
            margin: 0 20px;
            padding: 10px 20px;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        .nav a:hover {
            background-color: #f0f2ff;
        }
        .section {
            background: white;
            margin-bottom: 30px;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .section h2 {
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
            margin-top: 0;
        }
        .section h3 {
            color: #555;
            margin-top: 30px;
        }
        .endpoint {
            background: #f8f9fa;
            padding: 20px;
            margin: 15px 0;
            border-left: 4px solid #667eea;
            border-radius: 0 5px 5px 0;
        }
        .method {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
            color: white;
            font-size: 0.9em;
            margin-right: 10px;
        }
        .method.post { background-color: #28a745; }
        .method.put { background-color: #ffc107; color: #212529; }
        .method.get { background-color: #007bff; }
        .method.delete { background-color: #dc3545; }
        pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
        }
        .code-inline {
            background: #e2e8f0;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        .alert {
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            border-left: 4px solid;
        }
        .alert-info {
            background-color: #d1ecf1;
            border-color: #bee5eb;
            color: #0c5460;
        }
        .alert-warning {
            background-color: #fff3cd;
            border-color: #ffeaa7;
            color: #856404;
        }
        .alert-success {
            background-color: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }
        .table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        .table th, .table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }
        .table th {
            background-color: #f8f9fa;
            font-weight: 600;
        }
        .copy-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
            margin-left: 10px;
        }
        .copy-btn:hover {
            background: #5a67d8;
        }

        /* Language examples styling */
        .language-examples {
            margin: 20px 0;
        }

        .language-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .language-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }

        .language-item strong {
            color: #333;
            display: block;
            margin-bottom: 8px;
        }

        .language-item code {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 13px;
            color: #495057;
        }

        /* Parameter table styling */
        .parameter-table table {
            width: 100%;
            margin-top: 15px;
        }

        .parameter-table th {
            background: #f1f3f4;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }

        .parameter-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #dee2e6;
        }

        .parameter-table td:first-child code {
            background: #e3f2fd;
            color: #1976d2;
            padding: 3px 6px;
            border-radius: 3px;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="container">
            <h1>üìö AppenCorrect API Documentation</h1>
            <p>Complete guide for integrating with the AppenCorrect text correction service</p>
        </div>
    </div>

    <div class="container">
        <div class="nav">
            <a href="/">üè† Demo</a>
            <a href="/api-docs">üìö API Docs</a>
            <a href="/api-management">‚öôÔ∏è API Management</a>
            <a href="/health">üíö Health Check</a>
            <a href="/logout" style="color: #e53e3e; border: 1px solid #e53e3e;">üö™ Logout</a>
        </div>

        <!-- Getting Started -->
        <div class="section">
            <h2>üöÄ Getting Started</h2>
            
            <div class="alert alert-info">
                <strong>üìã Prerequisites:</strong> You need an API key to access AppenCorrect endpoints. Visit the <a href="/api-management">API Management page</a> to create one.
            </div>

            <h3>Authentication</h3>
            <p>All API endpoints (except <code class="code-inline">/health</code>) require authentication using an API key in the request header:</p>
            
            <pre><code>X-API-Key: appencorrect_your_api_key_here</code></pre>
            
            <p>Or using the Authorization header:</p>
            
            <pre><code>Authorization: Bearer appencorrect_your_api_key_here</code></pre>

            <h3>Base URL</h3>
            <p>All API requests should be made to:</p>
            <pre><code>{{ api_base_url }}</code></pre>
        </div>

        <!-- API Endpoints -->
        <div class="section">
            <h2>üîó API Endpoints</h2>

            <div class="endpoint">
                <h3><span class="method post">POST</span>/check</h3>
                <p><strong>Comprehensive text checking and correction</strong></p>
                <p>Analyzes text for spelling, grammar, and style issues using AI-powered correction.</p>
                
                <h4>Request Body:</h4>
                <pre><code>{
  "text": "This sentance has erors and bad grammer.",
  "language": "en-US",
  "use_case": "academic_writing",
  "options": {
    "ai_first_mode": true
  }
}</code></pre>

                <h4>Parameters:</h4>
                <div class="parameter-table">
                    <table>
                        <tr>
                            <th>Parameter</th>
                            <th>Type</th>
                            <th>Required</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td><code>text</code></td>
                            <td>string</td>
                            <td>‚úÖ</td>
                            <td>Text to be checked and corrected (max 10,000 characters)</td>
                        </tr>
                        <tr>
                            <td><code>language</code></td>
                            <td>string</td>
                            <td>‚ùå</td>
                            <td>Language/dialect code (e.g., "english", "en-US", "fr-CA", "es-MX") or "auto" for detection. Defaults to "auto".</td>
                        </tr>
                        <tr>
                            <td><code>use_case</code></td>
                            <td>string</td>
                            <td>‚ùå</td>
                            <td>Apply custom instructions for specific use case (e.g., "code_comments", "academic_writing")</td>
                        </tr>
                        <tr>
                            <td><code>options</code></td>
                            <td>object</td>
                            <td>‚ùå</td>
                            <td>Processing options</td>
                        </tr>
                    </table>
                </div>

                <h4>Example cURL:</h4>
                <pre><code>curl -X POST {{ api_base_url }}/check \
  -H "Content-Type: application/json" \
  -H "X-API-Key: appencorrect_your_api_key_here" \
  -d '{
    "text": "This sentance has erors and bad grammer.",
    "language": "en-US",
    "use_case": "academic_writing"
  }'</code></pre>

                <div class="alert alert-info">
                    <strong>üí° Custom Instructions:</strong> The <code>use_case</code> parameter applies any custom instructions you've configured for that use case. See the <a href="#custom-instructions-usage">Custom Instructions section</a> below for details.
                </div>

                <h4>Response:</h4>
                <pre><code>{
  "original_text": "This sentance has erors and bad grammer.",
  "processed_text": "This sentence has errors and bad grammar.",
  "corrections": [
    {
      "type": "spelling",
      "original": "sentance",
      "suggestion": "sentence",
      "position": [5, 13],
      "confidence": 0.95
    }
  ],
  "statistics": {
    "total_corrections": 3,
    "spelling_corrections": 2,
    "grammar_corrections": 1
  },
  "processing_time": 0.85,
  "detected_language": "en"
}</code></pre>
            </div>

            <div class="endpoint">
                <h3><span class="method post">POST</span>/check/spelling</h3>
                <p><strong>Spelling-only checking</strong></p>
                <p>Checks only for spelling errors, faster than comprehensive checking.</p>
                
                <h4>Request Body:</h4>
                <pre><code>{
  "text": "This sentance has speling erors.",
  "language": "en-GB",
  "use_case": "code_comments"
}</code></pre>

                <h4>Example cURL:</h4>
                <pre><code>curl -X POST {{ api_base_url }}/check/spelling \
  -H "Content-Type: application/json" \
  -H "X-API-Key: appencorrect_your_api_key_here" \
  -d '{
    "text": "This function has speling erors in {}",
    "language": "en-GB",
    "use_case": "code_comments"
  }'</code></pre>
            </div>

            <div class="endpoint">
                <h3><span class="method post">POST</span>/check/grammar</h3>
                <p><strong>Grammar-only checking</strong></p>
                <p>Focuses on grammatical errors and sentence structure.</p>
                
                <h4>Request Body:</h4>
                <pre><code>{
  "text": "I cant believe its working.",
  "language": "en-US",
  "use_case": "academic_writing"
}</code></pre>

                <h4>Example cURL:</h4>
                <pre><code>curl -X POST {{ api_base_url }}/check/grammar \
  -H "Content-Type: application/json" \
  -H "X-API-Key: appencorrect_your_api_key_here" \
  -d '{
    "text": "I cant believe its working.",
    "language": "en-US",
    "use_case": "academic_writing"
  }'</code></pre>
            </div>

            <div class="endpoint">
                <h3><span class="method post">POST</span>/assess/quality</h3>
                <p><strong>Comment quality assessment</strong></p>
                <p>Evaluates the quality of comments for rating tasks with comprehensive scoring.</p>
                
                <h4>Request Body:</h4>
                <pre><code>{
  "comment": "This product demonstrates excellent build quality with attention to detail that exceeds expectations. The materials feel premium and durable, while the design is both functional and aesthetically pleasing.",
  "rating_context": "Product review rating task"
}</code></pre>

                <h4>Example cURL:</h4>
                <pre><code>curl -X POST {{ api_base_url }}/assess/quality \
  -H "Content-Type: application/json" \
  -H "X-API-Key: appencorrect_your_api_key_here" \
  -d '{
    "comment": "This product is really good.",
    "rating_context": "Product review rating task"
  }'</code></pre>

                <h4>Response:</h4>
                <pre><code>{
  "quality_score": 7,
  "quality_level": "good",
  "assessment": "High quality comment with clear feedback...",
  "suggestions": [
    "Consider adding more specific details about what makes it good"
  ],
  "technical_corrections": [],
  "comment_analysis": {
    "character_count": 156,
    "length_category": "adequate"
  }
}</code></pre>
            </div>

            <div class="endpoint">
                <h3><span class="method post">POST</span>/feedback</h3>
                <p><strong>Submit feedback on AI corrections</strong></p>
                <p>Help improve the system by providing feedback on correction quality.</p>
                
                <h4>Request Body:</h4>
                <pre><code>{
  "original": "sentance",
  "ai_suggestion": "sentence",
  "feedback_type": "positive",
  "correction_type": "spelling",
  "confidence": 0.95
}</code></pre>
            </div>

            <div class="endpoint">
                <h3><span class="method post">POST</span> / <span class="method put">PUT</span>/custom-instructions</h3>
                <p><strong>Set or update custom instructions for a specific use case</strong></p>
                <p>Configure custom correction guidelines for different contexts (academic writing, code comments, etc.). Both POST and PUT methods work identically.</p>
                
                <h4>Request Body:</h4>
                <pre><code>{
  "use_case": "code_comments",
  "instructions": "Do not correct code formatting like {}, (), []. Preserve technical terminology. Use professional tone."
}</code></pre>

                <h4>Example cURL (POST):</h4>
                <pre><code>curl -X POST {{ api_base_url }}/custom-instructions \
  -H "Content-Type: application/json" \
  -H "X-API-Key: appencorrect_your_api_key_here" \
  -d '{
    "use_case": "academic_writing",
    "instructions": "Use formal tone. Avoid contractions. Prefer longer, more descriptive sentences."
  }'</code></pre>

                <h4>Example cURL (PUT):</h4>
                <pre><code>curl -X PUT {{ api_base_url }}/custom-instructions \
  -H "Content-Type: application/json" \
  -H "X-API-Key: appencorrect_your_api_key_here" \
  -d '{
    "use_case": "transcription",
    "instructions": "Numbers in Arabic format must be spelled out. Symbols like $ + = should be spelled out (dollars, plus, equals). Events like [laughter] stay in brackets."
  }'</code></pre>

                <h4>Response:</h4>
                <pre><code>{
  "status": "success",
  "message": "Custom instructions set for use case: academic_writing",
  "use_case": "academic_writing"
}</code></pre>

                <div class="alert alert-info">
                    <strong>üìù RESTful Notes:</strong> Both POST and PUT methods work identically for setting/updating custom instructions. Use POST for creating new instructions or PUT for updating existing ones - both achieve the same result.
                </div>
            </div>

            <div class="endpoint">
                <h3><span class="method get">GET</span>/custom-instructions</h3>
                <p><strong>Get custom instructions</strong></p>
                <p>Retrieve custom instructions for a specific use case or all instructions.</p>
                
                <h4>Query Parameters:</h4>
                <ul>
                    <li><code>use_case</code> (optional) - Specific use case to retrieve. If omitted, returns all instructions.</li>
                </ul>

                <h4>Example cURL:</h4>
                <pre><code># Get specific use case
curl -X GET "{{ api_base_url }}/custom-instructions?use_case=code_comments" \
  -H "X-API-Key: appencorrect_your_api_key_here"

# Get all instructions
curl -X GET "{{ api_base_url }}/custom-instructions" \
  -H "X-API-Key: appencorrect_your_api_key_here"</code></pre>

                <h4>Response (specific use case):</h4>
                <pre><code>{
  "status": "success",
  "use_case": "code_comments",
  "instructions": "Do not correct code formatting like {}, (), []..."
}</code></pre>

                <h4>Response (all instructions):</h4>
                <pre><code>{
  "status": "success",
  "custom_instructions": {
    "code_comments": "Do not correct code formatting...",
    "academic_writing": "Use formal tone. Avoid contractions..."
  }
}</code></pre>
            </div>

            <div class="endpoint">
                <h3><span class="method delete">DELETE</span>/custom-instructions</h3>
                <p><strong>Remove custom instructions</strong></p>
                <p>Remove custom instructions for a specific use case.</p>
                
                <h4>Query Parameters:</h4>
                <ul>
                    <li><code>use_case</code> (required) - Use case to remove instructions for.</li>
                </ul>

                <h4>Example cURL:</h4>
                <pre><code>curl -X DELETE "{{ api_base_url }}/custom-instructions?use_case=code_comments" \
  -H "X-API-Key: appencorrect_your_api_key_here"</code></pre>

                <h4>Response:</h4>
                <pre><code>{
  "status": "success",
  "message": "Custom instructions removed for use case: code_comments",
  "use_case": "code_comments"
}</code></pre>
            </div>

            <div class="endpoint">
                <h3><span class="method get">GET</span>/api/cache/status</h3>
                <p><strong>Get cache status for your API key</strong> ‚≠ê <em>NEW</em></p>
                <p>Returns cache information specific to your API key, including cache size and hit statistics.</p>
                
                <h4>Example cURL:</h4>
                <pre><code>curl -X GET {{ api_base_url }}/api/cache/status \
  -H "X-API-Key: your_api_key_here"</code></pre>

                <h4>Response:</h4>
                <pre><code>{
  "success": true,
  "cache_enabled": true,
  "cache_size": 15,
  "cache_hits": 42,
  "api_key_id": "ak_077d759ccc8a44da",
  "global_cache_available": true,
  "global_cache_connected": true,
  "timestamp": "2025-10-06T19:33:13.305195"
}</code></pre>

                <h4>Response Fields:</h4>
                <div class="parameter-table">
                    <table>
                        <tr>
                            <th>Field</th>
                            <th>Type</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td><code>cache_enabled</code></td>
                            <td>boolean</td>
                            <td>Whether caching is enabled for your API key</td>
                        </tr>
                        <tr>
                            <td><code>cache_size</code></td>
                            <td>integer</td>
                            <td>Number of cached responses for your API key</td>
                        </tr>
                        <tr>
                            <td><code>cache_hits</code></td>
                            <td>integer</td>
                            <td>Total cache hits since API key creation</td>
                        </tr>
                        <tr>
                            <td><code>api_key_id</code></td>
                            <td>string</td>
                            <td>Your API key identifier</td>
                        </tr>
                    </table>
                </div>
            </div>

            <div class="endpoint">
                <h3><span class="method post">POST</span>/api/cache/toggle</h3>
                <p><strong>Enable/disable cache for your API key</strong> ‚≠ê <em>NEW</em></p>
                <p>Toggle caching on or off for your specific API key only. Perfect for performance testing and A/B analysis without affecting other users.</p>
                
                <div class="alert alert-info">
                    <strong>üîí Isolation:</strong> This only affects YOUR API key. Other users' cache settings remain unchanged.
                </div>

                <h4>Request Body:</h4>
                <pre><code>{
  "enabled": false
}</code></pre>

                <h4>Parameters:</h4>
                <div class="parameter-table">
                    <table>
                        <tr>
                            <th>Parameter</th>
                            <th>Type</th>
                            <th>Required</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td><code>enabled</code></td>
                            <td>boolean</td>
                            <td>‚úÖ</td>
                            <td>Set to <code>true</code> to enable cache, <code>false</code> to disable</td>
                        </tr>
                    </table>
                </div>

                <h4>Example cURL:</h4>
                <pre><code># Disable cache for testing
curl -X POST {{ api_base_url }}/api/cache/toggle \
  -H "Content-Type: application/json" \
  -H "X-API-Key: your_api_key_here" \
  -d '{"enabled": false}'

# Re-enable cache
curl -X POST {{ api_base_url }}/api/cache/toggle \
  -H "Content-Type: application/json" \
  -H "X-API-Key: your_api_key_here" \
  -d '{"enabled": true}'</code></pre>

                <h4>Response:</h4>
                <pre><code>{
  "success": true,
  "cache_enabled": false,
  "cache_size": 0,
  "api_key_id": "ak_077d759ccc8a44da",
  "message": "Cache disabled for this API key",
  "timestamp": "2025-10-06T19:32:50.819780"
}</code></pre>

                <div class="alert alert-success">
                    <strong>‚úÖ Production Safe:</strong> Disabling cache only affects your API key, making it safe for production testing.
                </div>
            </div>

            <div class="endpoint">
                <h3><span class="method get">GET</span>/health</h3>
                <p><strong>System health check</strong></p>
                <p>Check if the API is running and all components are available. <em>No authentication required.</em></p>
                
                <h4>Example cURL:</h4>
                <pre><code>curl {{ api_base_url }}/health</code></pre>

                <h4>Response:</h4>
                <pre><code>{
  "status": "healthy",
  "timestamp": "2025-01-15T10:30:00Z",
  "version": "2.0.0",
  "components": {
    "gemini_ai": "available",
    "language_detector": "available",
    "ai_first_mode": "enabled"
  },
  "capabilities": ["spelling", "grammar", "language_detection", "ai_correction"]
}</code></pre>
            </div>
        </div>

        <!-- Rate Limits -->
        <div class="section">
            <h2>‚è±Ô∏è Rate Limits</h2>
            
            <div class="alert alert-warning">
                <strong>Rate Limiting:</strong> Each API key has usage limits to ensure fair access and system stability.
            </div>

            <table class="table">
                <thead>
                    <tr>
                        <th>Limit Type</th>
                        <th>Default Value</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Requests per Hour</td>
                        <td>1,000</td>
                        <td>Maximum API calls per hour per API key</td>
                    </tr>
                    <tr>
                        <td>Text Length</td>
                        <td>10,000 chars</td>
                        <td>Maximum characters per request</td>
                    </tr>
                    <tr>
                        <td>Comment Length</td>
                        <td>5,000 chars</td>
                        <td>Maximum characters for quality assessment</td>
                    </tr>
                </tbody>
            </table>

            <p>When rate limits are exceeded, you'll receive a <code class="code-inline">429 Too Many Requests</code> response.</p>
        </div>

        <!-- Error Handling -->
        <div class="section">
            <h2>‚ö†Ô∏è Error Handling</h2>
            
            <table class="table">
                <thead>
                    <tr>
                        <th>Status Code</th>
                        <th>Error Type</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>400</td>
                        <td>Bad Request</td>
                        <td>Invalid request format or missing required fields</td>
                    </tr>
                    <tr>
                        <td>401</td>
                        <td>Unauthorized</td>
                        <td>Missing or invalid API key</td>
                    </tr>
                    <tr>
                        <td>429</td>
                        <td>Too Many Requests</td>
                        <td>Rate limit exceeded</td>
                    </tr>
                    <tr>
                        <td>500</td>
                        <td>Internal Server Error</td>
                        <td>Server-side processing error</td>
                    </tr>
                </tbody>
            </tbody>

            <h3>Example Error Response:</h3>
            <pre><code>{
  "error": "Invalid API key",
  "message": "The provided API key is invalid or inactive"
}</code></pre>
        </div>

        <!-- Code Examples -->
        <div class="section">
            <h2>üíª Code Examples</h2>

            <h3>Python</h3>
            <pre><code>import requests

api_key = "appencorrect_your_api_key_here"
base_url = "{{ api_base_url }}"

headers = {
    "Content-Type": "application/json",
    "X-API-Key": api_key
}

# Text correction
response = requests.post(
    f"{base_url}/check",
    headers=headers,
    json={"text": "This sentance has erors."}
)

result = response.json()
print(f"Corrected: {result['processed_text']}")

# Comment quality assessment
response = requests.post(
    f"{base_url}/assess/quality",
    headers=headers,
    json={
        "comment": "This product is really good.",
        "rating_context": "Product review rating task"
    }
)

result = response.json()
print(f"Quality Score: {result['quality_score']}/10")</code></pre>

            <h3>JavaScript</h3>
            <pre><code>const apiKey = 'appencorrect_your_api_key_here';
const baseUrl = '{{ api_base_url }}';

const headers = {
    'Content-Type': 'application/json',
    'X-API-Key': apiKey
};

// Text correction
async function correctText(text) {
    const response = await fetch(`${baseUrl}/check`, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify({ text: text })
    });
    
    const result = await response.json();
    return result.processed_text;
}

// Comment quality assessment
async function assessQuality(comment, context) {
    const response = await fetch(`${baseUrl}/assess/quality`, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify({
            comment: comment,
            rating_context: context
        })
    });
    
    const result = await response.json();
    return result;
}

// Usage
correctText("This sentance has erors.").then(corrected => {
    console.log('Corrected:', corrected);
});</code></pre>

            <h3>PHP</h3>
            <pre><code>&lt;?php
$apiKey = 'appencorrect_your_api_key_here';
$baseUrl = '{{ api_base_url }}';

$headers = [
    'Content-Type: application/json',
    'X-API-Key: ' . $apiKey
];

// Text correction function
function correctText($text, $apiKey, $baseUrl) {
    $data = json_encode(['text' => $text]);
    
    $context = stream_context_create([
        'http' => [
            'method' => 'POST',
            'header' => implode("\r\n", [
                'Content-Type: application/json',
                'X-API-Key: ' . $apiKey
            ]),
            'content' => $data
        ]
    ]);
    
    $response = file_get_contents($baseUrl . '/check', false, $context);
    $result = json_decode($response, true);
    
    return $result['processed_text'];
}

// Usage
$corrected = correctText("This sentance has erors.", $apiKey, $baseUrl);
echo "Corrected: " . $corrected;
?&gt;</code></pre>
        </div>

        <!-- Frontend Integration -->
        <div class="section">
            <h2>üé® Frontend Integration Examples</h2>
            
            <div class="alert alert-success">
                <strong>Complete Frontend Implementation:</strong> Use these examples to create interactive correction bubbles and error highlighting in your application.
            </div>
            
            <div class="alert alert-info">
                <strong>‚è±Ô∏è Smart Debouncing Best Practice:</strong> The examples below use intelligent delays that adapt to typing patterns. This prevents checking incomplete words while users are actively typing, reducing false corrections and improving user experience.
            </div>

            <h3>HTML Structure</h3>
            <pre><code>&lt;!-- Text Editor Container --&gt;
&lt;div class="text-editor-container"&gt;
    &lt;textarea id="inputText" placeholder="Enter your text here..."&gt;&lt;/textarea&gt;
    &lt;div id="highlightedText" class="highlight-overlay"&gt;&lt;/div&gt;
    &lt;div class="status-indicator" id="statusIndicator"&gt;
        &lt;span class="status-icon"&gt;‚úÖ&lt;/span&gt;
        &lt;span class="status-text"&gt;Ready to check&lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;!-- Correction Bubble --&gt;
&lt;div class="correction-bubble" id="correctionBubble"&gt;
    &lt;div class="bubble-header"&gt;
        &lt;span class="bubble-type" id="bubbleType"&gt;GRAMMAR&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="bubble-correction"&gt;
        &lt;span class="bubble-original" id="bubbleOriginal"&gt;original&lt;/span&gt;
        &lt;span class="bubble-arrow"&gt;‚Üí&lt;/span&gt;
        &lt;span class="bubble-suggestion" id="bubbleSuggestion" onclick="applyCorrectionFromBubble()"&gt;suggestion&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="bubble-actions"&gt;
        &lt;button class="feedback-btn thumbs-up" onclick="submitFeedback('positive')" title="Good suggestion"&gt;üëç&lt;/button&gt;
        &lt;button class="feedback-btn thumbs-down" onclick="submitFeedback('negative')" title="Wrong suggestion"&gt;üëé&lt;/button&gt;
        &lt;button class="feedback-btn delete" onclick="deleteBubble()" title="Ignore this error"&gt;‚úï&lt;/button&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>

            <h3>CSS Styling</h3>
            <pre><code>/* Text Editor Container */
.text-editor-container {
    position: relative;
    width: 100%;
    max-width: 800px;
    margin: 0 auto;
}

/* Text Input */
#inputText {
    width: 100%;
    min-height: 200px;
    padding: 20px;
    border: 2px solid #e0e0e0;
    border-radius: 12px;
    font-size: 16px;
    font-family: 'Segoe UI', sans-serif;
    line-height: 1.6;
    resize: vertical;
    background: transparent;
    position: relative;
    z-index: 1;
}

/* Error Highlighting Overlay */
.highlight-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    padding: 20px;
    font-size: 16px;
    font-family: 'Segoe UI', sans-serif;
    line-height: 1.6;
    pointer-events: none;
    color: transparent;
    overflow: hidden;
    white-space: pre-wrap;
    word-wrap: break-word;
    border: 2px solid transparent;
    border-radius: 12px;
    box-sizing: border-box;
}

/* Error Highlights */
.error-highlight {
    background: rgba(255, 193, 7, 0.2);
    border-bottom: 2px wavy #dc3545;
    border-radius: 3px;
    cursor: pointer;
    pointer-events: all;
    color: transparent;
    position: relative;
    padding: 1px 2px;
}

.error-highlight:hover {
    background: rgba(255, 193, 7, 0.35);
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

/* Correction Bubble */
.correction-bubble {
    position: fixed;
    background: white;
    border: 2px solid #667eea;
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    padding: 16px;
    min-width: 280px;
    max-width: 400px;
    z-index: 9999;
    display: none;
    font-size: 14px;
}

.correction-bubble::before {
    content: '';
    position: absolute;
    top: -10px;
    left: 20px;
    width: 0;
    height: 0;
    border-left: 10px solid transparent;
    border-right: 10px solid transparent;
    border-bottom: 10px solid #667eea;
}

.correction-bubble::after {
    content: '';
    position: absolute;
    top: -8px;
    left: 21px;
    width: 0;
    height: 0;
    border-left: 9px solid transparent;
    border-right: 9px solid transparent;
    border-bottom: 9px solid white;
}

.bubble-type {
    background: #667eea;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
}

.bubble-correction {
    margin: 12px 0;
    padding: 8px;
    background: #f8f9fa;
    border-radius: 6px;
}

.bubble-suggestion {
    background: #28a745;
    color: white;
    padding: 2px 6px;
    border-radius: 3px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.bubble-suggestion:hover {
    background: #218838;
}

.feedback-btn {
    background: none;
    border: none;
    padding: 8px;
    cursor: pointer;
    border-radius: 4px;
    transition: background-color 0.2s;
}

.feedback-btn:hover {
    background: #f0f0f0;
}

/* Status Indicator */
.status-indicator {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
    margin-top: 15px;
    padding: 12px 16px;
    border-radius: 8px;
    transition: all 0.3s;
    font-weight: 500;
}</code></pre>

            <h3>JavaScript: Real-time Text Checking with Error Bubbles</h3>
            <pre><code>// Configuration
const apiKey = 'appencorrect_your_api_key_here';
const baseUrl = '{{ api_base_url }}';

// Global variables
let checkingTimeout;
let isChecking = false;
let lastCheckedText = '';
let currentCorrections = [];
let hoverTimeout;
let isHoveringBubble = false;

// Initialize text checking
function initializeTextChecker() {
    const inputText = document.getElementById('inputText');
    
    // Add event listeners for real-time checking
    inputText.addEventListener('input', handleTextChange);
    inputText.addEventListener('scroll', syncScrollPosition);
}

// Debounced text change handler
function handleTextChange() {
    const inputText = document.getElementById('inputText');
    const fullText = inputText.value;
    
    // Clear previous checking timeout
    if (checkingTimeout) {
        clearTimeout(checkingTimeout);
    }
    
    // Update status
    updateStatus('checking', 'üîÑ', 'Checking grammar...');
    inputText.classList.add('checking');
    
    // Smart debounce - longer delay if user appears to be mid-word
    const delay = getSmartDelay(fullText);
    checkingTimeout = setTimeout(() => {
        // Double-check text hasn't changed during delay
        if (inputText.value === fullText) {
            checkTextRealtime(fullText);
        }
    }, delay);
}

// Calculate smart delay to avoid checking while user is actively typing
function getSmartDelay(text) {
    let delay = 1500; // Base delay
    
    const trimmedText = text.trim();
    const lastChar = trimmedText.slice(-1);
    
    // FAST: Complete sentences (ends with punctuation)
    if (/[.!?;]/.test(lastChar)) return 800;
    
    // FAST: Phrase completion
    if (/[,:)}\]]/.test(lastChar)) return 1200;
    
    // SLOW: Incomplete words
    const endsWithWordChar = /[a-zA-Z0-9]/.test(lastChar);
    const hasRecentSpace = text.slice(-10).includes(' ');
    
    if (endsWithWordChar && !hasRecentSpace) delay = 2500;
    if (trimmedText.length < 15) delay = Math.max(delay, 2000);
    if (/\b[a-z]+$/.test(trimmedText)) delay = 2500;
    
    return delay;
}

// Real-time text checking function
async function checkTextRealtime(text) {
    if (isChecking) return;
    
    console.log('Starting text check...');
    isChecking = true;
    lastCheckedText = text;
    
    const startTime = performance.now();
    
    try {
        const response = await fetch(`${baseUrl}/check`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-API-Key': apiKey
            },
            body: JSON.stringify({
                text: text,
                options: { ai_first_mode: true }
            })
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP error! status: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        const responseTime = performance.now() - startTime;
        
        handleRealtimeResults(data, responseTime);

    } catch (error) {
        console.error('Error in text checking:', error);
        updateStatus('ready', '‚ö†Ô∏è', 'Check failed - try again');
    } finally {
        isChecking = false;
        clearTextStyling();
    }
}

// Handle API results and update UI
function handleRealtimeResults(data, responseTime) {
    currentCorrections = data.corrections || [];
    
    if (currentCorrections.length > 0) {
        updateStatus('errors', '‚ö†Ô∏è', `${currentCorrections.length} correction${currentCorrections.length > 1 ? 's' : ''} found`);
        highlightErrors(currentCorrections);
        document.getElementById('inputText').classList.add('has-errors');
    } else {
        updateStatus('clean', '‚úÖ', 'Text looks great!');
        clearOverlayHighlights();
        document.getElementById('inputText').classList.add('no-errors');
    }
    
    // Update statistics if needed
    updateStatistics(currentCorrections, responseTime);
}

// Highlight errors in the text
function highlightErrors(corrections) {
    const inputText = document.getElementById("inputText");
    const highlightedText = document.getElementById("highlightedText");
    let text = inputText.value;
    
    if (!corrections || corrections.length === 0) {
        highlightedText.style.display = 'none';
        return;
    }
    
    // Create HTML with error highlights
    let htmlContent = escapeHtml(text);
    
    // Sort corrections by position (latest first to avoid position shifts)
    const sortedCorrections = corrections
        .filter(c => c.position && c.position.length >= 2)
        .sort((a, b) => b.position[0] - a.position[0]);
    
    sortedCorrections.forEach((correction, index) => {
        const [startPos, endPos] = correction.position;
        const before = htmlContent.substring(0, startPos);
        const after = htmlContent.substring(endPos);
        const originalText = htmlContent.substring(startPos, endPos);
        
        const highlightedWord = `&lt;span class="error-highlight" 
            data-original="${escapeHtml(correction.original)}"
            data-suggestion="${escapeHtml(correction.suggestion)}"
            data-type="${escapeHtml(correction.type)}"
            data-confidence="${correction.confidence}"
            title="Click to change '${escapeHtml(correction.original)}' to '${escapeHtml(correction.suggestion)}'"
            onmouseenter="showHoverBubble(event)"
            onmouseleave="hideHoverBubble()"
            onclick="applyCorrection(event)"&gt;${originalText}&lt;/span&gt;`;
        
        htmlContent = before + highlightedWord + after;
    });
    
    highlightedText.innerHTML = htmlContent;
    highlightedText.style.display = 'block';
}

// Show correction bubble on hover
function showHoverBubble(event) {
    clearTimeout(hoverTimeout);
    
    const span = event.target;
    const correction = {
        original: span.getAttribute("data-original"),
        suggestion: span.getAttribute("data-suggestion"),
        type: span.getAttribute("data-type"),
        confidence: parseFloat(span.getAttribute("data-confidence"))
    };
    
    const bubble = document.getElementById("correctionBubble");
    const bubbleType = document.getElementById("bubbleType");
    const bubbleOriginal = document.getElementById("bubbleOriginal");
    const bubbleSuggestion = document.getElementById("bubbleSuggestion");
    
    bubbleType.textContent = correction.type.toUpperCase();
    bubbleOriginal.textContent = correction.original;
    bubbleSuggestion.textContent = correction.suggestion;
    
    // Position bubble near the error
    const rect = span.getBoundingClientRect();
    let left = rect.left;
    let top = rect.bottom + 5;
    
    const bubbleWidth = 300;
    if (left + bubbleWidth > window.innerWidth) {
        left = window.innerWidth - bubbleWidth - 20;
    }
    if (left < 10) left = 10;
    
    bubble.style.left = `${left}px`;
    bubble.style.top = `${top}px`;
    bubble.style.display = "block";
    window.currentHoverCorrection = correction;
}

// Hide correction bubble
function hideHoverBubble() {
    hoverTimeout = setTimeout(() => {
        const bubble = document.getElementById("correctionBubble");
        const isOverBubble = bubble.matches(":hover");
        const isOverHighlight = document.querySelector(".error-highlight:hover");
        
        if (!isOverBubble && !isOverHighlight && !isHoveringBubble) {
            bubble.style.display = "none";
            window.currentHoverCorrection = null;
        }
    }, 300);
}

// Apply correction from bubble
function applyCorrectionFromBubble() {
    const correction = window.currentHoverCorrection;
    if (!correction) return;
    
    const inputText = document.getElementById('inputText');
    const currentText = inputText.value;
    
    // Apply the correction
    const newText = currentText.replace(correction.original, correction.suggestion);
    inputText.value = newText;
    
    // Remove the correction from current list
    currentCorrections = currentCorrections.filter(c => 
        !(c.original === correction.original && c.suggestion === correction.suggestion)
    );
    
    // Update highlights
    highlightErrors(currentCorrections);
    
    // Hide bubble
    document.getElementById('correctionBubble').style.display = 'none';
    window.currentHoverCorrection = null;
}

// Update status indicator
function updateStatus(type, icon, message) {
    const indicator = document.getElementById('statusIndicator');
    const iconElement = indicator.querySelector('.status-icon');
    const textElement = indicator.querySelector('.status-text');
    
    iconElement.textContent = icon;
    textElement.textContent = message;
    
    // Update styling based on status type
    indicator.className = `status-indicator status-${type}`;
}

// Utility functions
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function clearOverlayHighlights() {
    const highlightedText = document.getElementById("highlightedText");
    if (highlightedText) {
        highlightedText.style.display = 'none';
        highlightedText.innerHTML = '';
    }
}

function syncScrollPosition() {
    const inputText = document.getElementById('inputText');
    const highlightedText = document.getElementById('highlightedText');
    
    if (highlightedText) {
        highlightedText.scrollTop = inputText.scrollTop;
        highlightedText.scrollLeft = inputText.scrollLeft;
    }
}

// Submit feedback for corrections
async function submitFeedback(feedbackType) {
    const correction = window.currentHoverCorrection;
    if (!correction) return;
    
    try {
        const response = await fetch(`${baseUrl}/feedback`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-API-Key': apiKey
            },
            body: JSON.stringify({
                original: correction.original,
                ai_suggestion: correction.suggestion,
                feedback_type: feedbackType,
                correction_type: correction.type,
                confidence: correction.confidence
            })
        });
        
        if (response.ok) {
            console.log('Feedback submitted successfully');
            // Hide bubble after feedback
            document.getElementById('correctionBubble').style.display = 'none';
        }
    } catch (error) {
        console.error('Error submitting feedback:', error);
    }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    initializeTextChecker();
});</code></pre>

            <h3>Complete Working Example</h3>
            <p>Here's a complete HTML page that demonstrates how to integrate AppenCorrect into your application:</p>
            
            <pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;AppenCorrect Integration Example&lt;/title&gt;
    &lt;style&gt;
        /* Include all the CSS from above */
        .text-editor-container { position: relative; width: 100%; max-width: 800px; margin: 0 auto; }
        #inputText { width: 100%; min-height: 200px; padding: 20px; border: 2px solid #e0e0e0; border-radius: 12px; font-size: 16px; }
        .highlight-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; color: transparent; }
        .error-highlight { background: rgba(255, 193, 7, 0.2); border-bottom: 2px wavy #dc3545; cursor: pointer; pointer-events: all; }
        .correction-bubble { position: fixed; background: white; border: 2px solid #667eea; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); padding: 16px; z-index: 9999; display: none; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Text Correction Example&lt;/h1&gt;
    
    &lt;div class="text-editor-container"&gt;
        &lt;textarea id="inputText" placeholder="Type your text here for real-time correction..."&gt;&lt;/textarea&gt;
        &lt;div id="highlightedText" class="highlight-overlay"&gt;&lt;/div&gt;
        &lt;div class="status-indicator" id="statusIndicator"&gt;
            &lt;span class="status-icon"&gt;‚úÖ&lt;/span&gt;
            &lt;span class="status-text"&gt;Ready to check&lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class="correction-bubble" id="correctionBubble"&gt;
        &lt;div class="bubble-header"&gt;
            &lt;span class="bubble-type" id="bubbleType"&gt;GRAMMAR&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class="bubble-correction"&gt;
            &lt;span class="bubble-original" id="bubbleOriginal"&gt;original&lt;/span&gt;
            &lt;span class="bubble-arrow"&gt;‚Üí&lt;/span&gt;
            &lt;span class="bubble-suggestion" id="bubbleSuggestion" onclick="applyCorrectionFromBubble()"&gt;suggestion&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class="bubble-actions"&gt;
            &lt;button class="feedback-btn thumbs-up" onclick="submitFeedback('positive')"&gt;üëç&lt;/button&gt;
            &lt;button class="feedback-btn thumbs-down" onclick="submitFeedback('negative')"&gt;üëé&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // Include all the JavaScript from above
        const apiKey = 'your_api_key_here';
        const baseUrl = '{{ api_base_url }}';
        
        // Add all the functions: checkTextRealtime, highlightErrors, showHoverBubble, etc.
        // (See complete code above)
        
        // Initialize
        document.addEventListener('DOMContentLoaded', initializeTextChecker);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>

            <h3>React.js Component Example</h3>
            <pre><code>{% raw %}import React, { useState, useEffect, useRef } from 'react';

const TextCorrector = ({ apiKey, baseUrl = '{{ api_base_url }}' }) => {
    const [text, setText] = useState('');
    const [corrections, setCorrections] = useState([]);
    const [isChecking, setIsChecking] = useState(false);
    const [status, setStatus] = useState({ type: 'ready', icon: '‚úÖ', message: 'Ready to check' });
    const [showBubble, setShowBubble] = useState(false);
    const [bubbleData, setBubbleData] = useState(null);
    const [bubblePosition, setBubblePosition] = useState({ x: 0, y: 0 });
    
    const textareaRef = useRef(null);
    const checkingTimeoutRef = useRef(null);

    // Debounced text checking
    useEffect(() => {
        if (checkingTimeoutRef.current) {
            clearTimeout(checkingTimeoutRef.current);
        }

        if (text.trim().length === 0) {
            setCorrections([]);
            setStatus({ type: 'ready', icon: '‚úÖ', message: 'Ready to check' });
            return;
        }

        setStatus({ type: 'checking', icon: 'üîÑ', message: 'Checking...' });
        
        const delay = getSmartDelay(text);
        checkingTimeoutRef.current = setTimeout(() => {
            checkText(text);
        }, delay);

        return () => {
            if (checkingTimeoutRef.current) {
                clearTimeout(checkingTimeoutRef.current);
            }
        };
    }, [text]);

    const checkText = async (textToCheck) => {
        if (isChecking) return;
        
        setIsChecking(true);
        
        try {
            const response = await fetch(`${baseUrl}/check`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-API-Key': apiKey
                },
                body: JSON.stringify({
                    text: textToCheck,
                    options: { ai_first_mode: true }
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            setCorrections(data.corrections || []);
            
            if (data.corrections && data.corrections.length > 0) {
                setStatus({ 
                    type: 'errors', 
                    icon: '‚ö†Ô∏è', 
                    message: `${data.corrections.length} correction${data.corrections.length > 1 ? 's' : ''} found` 
                });
            } else {
                setStatus({ type: 'clean', icon: '‚úÖ', message: 'Text looks great!' });
            }

        } catch (error) {
            console.error('Error checking text:', error);
            setStatus({ type: 'error', icon: '‚ö†Ô∏è', message: 'Check failed - try again' });
        } finally {
            setIsChecking(false);
        }
    };

    const handleErrorClick = (correction, event) => {
        const rect = event.target.getBoundingClientRect();
        setBubblePosition({ x: rect.left, y: rect.bottom + 5 });
        setBubbleData(correction);
        setShowBubble(true);
    };

    const applyCorrection = (correction) => {
        const newText = text.replace(correction.original, correction.suggestion);
        setText(newText);
        setShowBubble(false);
        
        // Remove applied correction from list
        setCorrections(prev => prev.filter(c => 
            !(c.original === correction.original && c.suggestion === correction.suggestion)
        ));
    };

    const renderHighlightedText = () => {
        if (!corrections.length) return text;
        
        let highlightedText = text;
        const sortedCorrections = [...corrections]
            .filter(c => c.position && c.position.length >= 2)
            .sort((a, b) => b.position[0] - a.position[0]);

        sortedCorrections.forEach(correction => {
            const [start, end] = correction.position;
            const before = highlightedText.substring(0, start);
            const after = highlightedText.substring(end);
            const errorText = highlightedText.substring(start, end);
            
            highlightedText = before + 
                `<mark class="error-highlight" onclick="handleErrorClick" data-correction='${JSON.stringify(correction)}'>${errorText}</mark>` + 
                after;
        });
        
        return highlightedText;
    };

    return (
        &lt;div className="text-corrector"&gt;
            &lt;div className="text-editor-container"&gt;
                &lt;textarea
                    ref={textareaRef}
                    value={text}
                    onChange={(e) =&gt; setText(e.target.value)}
                    placeholder="Enter your text here for real-time correction..."
                    rows={8}
                /&gt;
                
                &lt;div className={`status-indicator status-${status.type}`}&gt;
                    &lt;span&gt;{status.icon}&lt;/span&gt;
                    &lt;span&gt;{status.message}&lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            {showBubble && bubbleData && (
                &lt;div 
                    className="correction-bubble"
                    style={{ 
                        left: bubblePosition.x, 
                        top: bubblePosition.y,
                        position: 'fixed',
                        display: 'block'
                    }}
                &gt;
                    &lt;div className="bubble-header"&gt;
                        &lt;span className="bubble-type"&gt;{bubbleData.type.toUpperCase()}&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div className="bubble-correction"&gt;
                        &lt;span&gt;{bubbleData.original}&lt;/span&gt;
                        &lt;span&gt; ‚Üí &lt;/span&gt;
                        &lt;button onClick={() =&gt; applyCorrection(bubbleData)}&gt;
                            {bubbleData.suggestion}
                        &lt;/button&gt;
                    &lt;/div&gt;
                    &lt;div className="bubble-actions"&gt;
                        &lt;button onClick={() =&gt; setShowBubble(false)}&gt;Close&lt;/button&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            )}
        &lt;/div&gt;
    );
};

export default TextCorrector;{% endraw %}</code></pre>

            <h3>Vue.js Component Example</h3>
            <pre><code>{% raw %}&lt;template&gt;
  &lt;div class="text-corrector"&gt;
    &lt;div class="text-editor-container"&gt;
      &lt;textarea
        v-model="text"
        @input="handleTextChange"
        placeholder="Enter your text here for real-time correction..."
        rows="8"
      &gt;&lt;/textarea&gt;
      
      &lt;div :class="`status-indicator status-${status.type}`"&gt;
        &lt;span&gt;{{ status.icon }}&lt;/span&gt;
        &lt;span&gt;{{ status.message }}&lt;/span&gt;
      &lt;/div&gt;
      
      &lt;div 
        v-if="corrections.length"
        class="corrections-summary"
      &gt;
        Found {{ corrections.length }} correction{{ corrections.length > 1 ? 's' : '' }}
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div 
      v-if="showBubble && bubbleData"
      class="correction-bubble"
      :style="{ left: bubblePosition.x + 'px', top: bubblePosition.y + 'px' }"
    &gt;
      &lt;div class="bubble-header"&gt;
        &lt;span class="bubble-type"&gt;{{ bubbleData.type.toUpperCase() }}&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class="bubble-correction"&gt;
        &lt;span&gt;{{ bubbleData.original }}&lt;/span&gt;
        &lt;span&gt; ‚Üí &lt;/span&gt;
        &lt;button @click="applyCorrection(bubbleData)"&gt;
          {{ bubbleData.suggestion }}
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  props: {
    apiKey: { type: String, required: true },
    baseUrl: { type: String, default: '{{ api_base_url }}' }
  },
  
  data() {
    return {
      text: '',
      corrections: [],
      isChecking: false,
      status: { type: 'ready', icon: '‚úÖ', message: 'Ready to check' },
      showBubble: false,
      bubbleData: null,
      bubblePosition: { x: 0, y: 0 },
      checkingTimeout: null
    };
  },
  
  methods: {
    handleTextChange() {
      if (this.checkingTimeout) {
        clearTimeout(this.checkingTimeout);
      }
      
      this.status = { type: 'checking', icon: 'üîÑ', message: 'Checking...' };
      
      const delay = this.getSmartDelay(this.text);
      this.checkingTimeout = setTimeout(() => {
        this.checkText();
      }, delay);
    },
    
    getSmartDelay(text) {
      const trimmedText = text.trim();
      const lastChar = trimmedText.slice(-1);
      
      // FAST: Complete sentences
      if (/[.!?;]/.test(lastChar)) return 800;
      if (/[,:)}\]]/.test(lastChar)) return 1200;
      
      // SLOW: Incomplete patterns
      let delay = 1500;
      const endsWithWordChar = /[a-zA-Z0-9]/.test(lastChar);
      const hasRecentSpace = text.slice(-10).includes(' ');
      
      if (endsWithWordChar && !hasRecentSpace) delay = 2500;
      if (trimmedText.length < 15) delay = Math.max(delay, 2000);
      if (/\\b[a-z]+$/.test(trimmedText)) delay = 2500;
      
      return delay;
    },
    
    async checkText() {
      if (this.isChecking || !this.text.trim()) return;
      
      this.isChecking = true;
      
      try {
        const response = await fetch(`${this.baseUrl}/check`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-API-Key': this.apiKey
          },
          body: JSON.stringify({
            text: this.text,
            options: { ai_first_mode: true }
          })
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        this.corrections = data.corrections || [];
        
        if (this.corrections.length > 0) {
          this.status = { 
            type: 'errors', 
            icon: '‚ö†Ô∏è', 
            message: `${this.corrections.length} correction${this.corrections.length > 1 ? 's' : ''} found` 
          };
        } else {
          this.status = { type: 'clean', icon: '‚úÖ', message: 'Text looks great!' };
        }

      } catch (error) {
        console.error('Error checking text:', error);
        this.status = { type: 'error', icon: '‚ö†Ô∏è', message: 'Check failed - try again' };
      } finally {
        this.isChecking = false;
      }
    },
    
    applyCorrection(correction) {
      this.text = this.text.replace(correction.original, correction.suggestion);
      this.corrections = this.corrections.filter(c => 
        !(c.original === correction.original && c.suggestion === correction.suggestion)
      );
      this.showBubble = false;
    }
  }
};
&lt;/script&gt;{% endraw %}</code></pre>
        </div>

        <!-- Response Format -->
        <div class="section">
            <h2>üìÑ Response Formats</h2>

            <h3>Text Correction Response</h3>
            <pre><code>{
  "original_text": "Input text",
  "processed_text": "Corrected text",
  "corrections": [
    {
      "type": "spelling|grammar|style",
      "original": "original word/phrase",
      "suggestion": "suggested correction",
      "position": [start_index, end_index],
      "confidence": 0.95,
      "explanation": "Why this correction was suggested"
    }
  ],
  "statistics": {
    "total_corrections": 3,
    "spelling_corrections": 2,
    "grammar_corrections": 1,
    "style_corrections": 0
  },
  "detected_language": "en",
  "processing_time": 0.85
}</code></pre>

            <h3>Comment Quality Assessment Response</h3>
            <pre><code>{
  "quality_score": 7,
  "quality_level": "good",
  "assessment": "Detailed quality assessment...",
  "suggestions": [
    "Specific improvement suggestions..."
  ],
  "strengths": [
    "What the comment does well..."
  ],
  "technical_corrections": [
    {
      "type": "spelling",
      "original": "eror",
      "suggestion": "error"
    }
  ],
  "comment_analysis": {
    "character_count": 156,
    "word_count": 28,
    "sentence_count": 3,
    "length_category": "adequate",
    "detected_language": "en"
  },
  "quality_factors": {
    "technical_quality": 8.5,
    "content_quality": 7.0,
    "length_appropriateness": 6.5,
    "rating_task_suitability": 7.5
  }
}</code></pre>
        </div>

        <!-- Supported Languages -->
        <div class="section">
            <h2>üåç Universal Language Support</h2>
            
            <div class="alert alert-info">
                <strong>üéØ Any Language/Dialect:</strong> AppenCorrect accepts any language or dialect specification in the <code>language</code> parameter. The AI will adapt its correction rules accordingly.
            </div>

            <h3>Language Specification Options</h3>
            <p>You can specify languages in multiple formats:</p>
            
            <table class="table">
                <thead>
                    <tr>
                        <th>Format</th>
                        <th>Example</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Auto-Detection</strong></td>
                        <td><code>"auto"</code></td>
                        <td>Automatically detects the language (default behavior)</td>
                    </tr>
                    <tr>
                        <td><strong>Language Names</strong></td>
                        <td><code>"english"</code>, <code>"french"</code>, <code>"spanish"</code></td>
                        <td>Plain language names</td>
                    </tr>
                    <tr>
                        <td><strong>Standard Codes</strong></td>
                        <td><code>"en"</code>, <code>"fr"</code>, <code>"es"</code>, <code>"de"</code></td>
                        <td>ISO 639-1 language codes</td>
                    </tr>
                    <tr>
                        <td><strong>Locale Codes</strong></td>
                        <td><code>"en-US"</code>, <code>"en-GB"</code>, <code>"fr-CA"</code>, <code>"es-MX"</code></td>
                        <td>Language with regional variants</td>
                    </tr>
                    <tr>
                        <td><strong>Custom Dialects</strong></td>
                        <td><code>"en-medical"</code>, <code>"legal-terminology"</code></td>
                        <td>Custom specifications for specialized domains</td>
                    </tr>
                </tbody>
            </table>

            <h3>Popular Language Examples</h3>
            <div class="language-examples">
                <div class="language-grid">
                    <div class="language-item">
                        <strong>üá∫üá∏ English Variants</strong><br>
                        <code>"en-US"</code> - American English<br>
                        <code>"en-GB"</code> - British English<br>
                        <code>"en-CA"</code> - Canadian English<br>
                        <code>"en-AU"</code> - Australian English
                    </div>
                    <div class="language-item">
                        <strong>üá´üá∑ French Variants</strong><br>
                        <code>"fr-FR"</code> - French (France)<br>
                        <code>"fr-CA"</code> - Canadian French<br>
                        <code>"fr-CH"</code> - Swiss French<br>
                        <code>"fr-BE"</code> - Belgian French
                    </div>
                    <div class="language-item">
                        <strong>üá™üá∏ Spanish Variants</strong><br>
                        <code>"es-ES"</code> - Spanish (Spain)<br>
                        <code>"es-MX"</code> - Mexican Spanish<br>
                        <code>"es-AR"</code> - Argentinian Spanish<br>
                        <code>"es-CO"</code> - Colombian Spanish
                    </div>
                    <div class="language-item">
                        <strong>üåç Other Languages</strong><br>
                        <code>"de-DE"</code> - German<br>
                        <code>"it-IT"</code> - Italian<br>
                        <code>"pt-BR"</code> - Brazilian Portuguese<br>
                        <code>"zh-CN"</code> - Chinese (Simplified)
                    </div>
                </div>
            </div>

            <div class="alert alert-warning">
                <strong>üí° How It Works:</strong> For recognized languages, the AI applies specific grammar rules and conventions. For unknown language codes, the system gracefully falls back to auto-detection while still processing the text successfully.
            </div>

            <h3>Language Parameter Examples</h3>
            <p>Here are practical examples of using the language parameter:</p>

            <div class="endpoint">
                <h4>Auto-Detection (Default)</h4>
                <pre><code>curl -X POST /check \
  -H "Content-Type: application/json" \
  -H "X-API-Key: your_key_here" \
  -d '{"text": "Hello world", "language": "auto"}'</code></pre>
            </div>

            <div class="endpoint">
                <h4>British English Spelling</h4>
                <pre><code>curl -X POST /check \
  -H "Content-Type: application/json" \
  -H "X-API-Key: your_key_here" \
  -d '{"text": "I realise the colour is grey", "language": "en-GB"}'</code></pre>
            </div>

            <div class="endpoint">
                <h4>Canadian French</h4>
                <pre><code>curl -X POST /check \
  -H "Content-Type: application/json" \
  -H "X-API-Key: your_key_here" \
  -d '{"text": "Je voudrais un caf√©", "language": "fr-CA"}'</code></pre>
            </div>

            <div class="endpoint">
                <h4>Custom Domain-Specific</h4>
                <pre><code>curl -X POST /check \
  -H "Content-Type: application/json" \
  -H "X-API-Key: your_key_here" \
  -d '{"text": "Medical terminology", "language": "en-medical"}'</code></pre>
            </div>
        </div>

        <!-- Custom Instructions Usage -->
        <div class="section" id="custom-instructions-usage">
            <h2>üéØ Custom Instructions Usage</h2>
            
            <div class="alert alert-info">
                <strong>üîß Flexible Guidelines:</strong> Custom instructions allow you to tailor text corrections for specific use cases, writing styles, or organizational guidelines.
            </div>

            <h3>Common Use Cases</h3>
            <div class="language-examples">
                <div class="language-grid">
                    <div class="language-item">
                        <strong>üìù Academic Writing</strong><br>
                        "Use formal tone. Avoid contractions. Prefer longer, more descriptive sentences."
                    </div>
                    <div class="language-item">
                        <strong>üíª Code Comments</strong><br>
                        "Do not correct code formatting like {}, (), []. Preserve technical terminology."
                    </div>
                    <div class="language-item">
                        <strong>üì± Marketing Copy</strong><br>
                        "Use energetic, engaging tone. Preserve brand voice. Keep sentences punchy."
                    </div>
                    <div class="language-item">
                        <strong>üìö Documentation</strong><br>
                        "Use clear, instructional language. Avoid ambiguity. Include step-by-step clarity."
                    </div>
                </div>
            </div>

            <h3>Step-by-Step Workflow</h3>
            <div class="endpoint">
                <h4>1. Set Custom Instructions</h4>
                <pre><code># Create new instructions (POST) or update existing (PUT)
curl -X POST /custom-instructions \
  -H "Content-Type: application/json" \
  -H "X-API-Key: your_key" \
  -d '{"use_case": "code_review", "instructions": "Preserve {}, (), [] brackets. Use professional tone."}'

# Alternative: Use PUT for updates
curl -X PUT /custom-instructions \
  -H "Content-Type: application/json" \
  -H "X-API-Key: your_key" \
  -d '{"use_case": "code_review", "instructions": "Updated instructions..."}'</code></pre>
            </div>

            <div class="endpoint">
                <h4>2. Use Custom Instructions</h4>
                <pre><code>curl -X POST /check \
  -H "Content-Type: application/json" \
  -H "X-API-Key: your_key" \
  -d '{"text": "This function uses {} for paramters", "use_case": "code_review"}'</code></pre>
            </div>

            <div class="endpoint">
                <h4>3. Result with Custom Instructions Applied</h4>
                <pre><code>{
  "corrections": [
    {"original": "paramters", "suggestion": "parameters", "type": "spelling"}
  ],
  "processed_text": "This function uses {} for parameters"
}</code></pre>
                <p><em>Notice: {} brackets preserved, only genuine spelling error corrected</em></p>
            </div>
        </div>

        <!-- Best Practices -->
        <div class="section">
            <h2>üí° Best Practices</h2>
            
            <div class="alert alert-info">
                <strong>Performance Tips:</strong> Follow these guidelines for optimal API usage.
            </div>

            <h3>üöÄ Performance Optimization</h3>
            <ul>
                <li><strong>Batch requests:</strong> Combine multiple sentences into one request when possible</li>
                <li><strong>Use specific endpoints:</strong> Use <code>/check/spelling</code> if you only need spelling checks</li>
                <li><strong>Cache results:</strong> Cache API responses to avoid duplicate requests</li>
                <li><strong>Per-API-key cache control:</strong> Use <code>/api/cache/toggle</code> to disable caching for performance testing without affecting other users</li>
                <li><strong>Handle rate limits:</strong> Implement exponential backoff when receiving 429 responses</li>
            </ul>

            <h3>üìè Text Length Guidelines</h3>
            <ul>
                <li><strong>Regular text checking:</strong> Up to 10,000 characters per request</li>
                <li><strong>Comment quality assessment:</strong> Up to 5,000 characters per request</li>
                <li><strong>Optimal length:</strong> 300-2000 characters for best results</li>
                <li><strong>Very short text:</strong> May receive limited corrections</li>
            </ul>

            <h3>üéØ Quality Assessment Tips</h3>
            <ul>
                <li><strong>Provide context:</strong> Use the <code>rating_context</code> parameter for better assessment</li>
                <li><strong>Length matters:</strong> Comments under 100 characters are capped at 4/10 quality score</li>
                <li><strong>Excellence threshold:</strong> Comments need 300+ characters to achieve 9-10/10 scores</li>
                <li><strong>Use feedback:</strong> Submit feedback to help improve the system</li>
            </ul>
        </div>

        <!-- Footer -->
        <div class="section">
            <h2>üÜò Support & Resources</h2>
            
            <div class="alert alert-info">
                <strong>Need Help?</strong> Check these resources or contact support.
            </div>

            <ul>
                <li><strong>API Management:</strong> <a href="/api-management">Manage your API keys</a></li>
                <li><strong>Health Check:</strong> <a href="/health">System status</a></li>
                <li><strong>Interactive Demo:</strong> <a href="/">Try the web interface</a></li>
                <li><strong>API Documentation:</strong> <a href="/api-docs">Complete API reference</a></li>
            </ul>

            <p style="text-align: center; margin-top: 40px; color: #666;">
                <strong>AppenCorrect API v2.0.0</strong><br>
                Advanced AI-Powered Text Correction & Comment Quality Assessment
            </p>
        </div>
    </div>

    <script>
        // Copy code functionality
        document.querySelectorAll('.copy-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const code = this.previousElementSibling.textContent;
                navigator.clipboard.writeText(code).then(() => {
                    this.textContent = 'Copied!';
                    setTimeout(() => {
                        this.textContent = 'Copy';
                    }, 2000);
                });
            });
        });
    </script>
</body>
</html>
