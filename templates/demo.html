<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AppenCorrect Demo - AI-Powered Grammar & Spell Checker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            line-height: 1.6;
        }

        /* Navigation */
        .nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0,0,0,0.1);
            z-index: 1000;
            padding: 15px 0;
        }

        .nav-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-logo {
            font-size: 1.5em;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .nav-links {
            display: flex;
            gap: 30px;
        }

        .nav-links a {
            text-decoration: none;
            color: #333;
            font-weight: 500;
            transition: color 0.3s;
        }

        .nav-links a:hover {
            color: #667eea;
        }

        /* Hero Section */
        .hero {
            padding: 120px 20px 80px;
            text-align: center;
            color: white;
        }

        .hero-content {
            max-width: 800px;
            margin: 0 auto;
        }

        .hero h1 {
            font-size: 3.5em;
            font-weight: 300;
            margin-bottom: 20px;
            line-height: 1.2;
        }

        .hero .subtitle {
            font-size: 1.3em;
            opacity: 0.9;
            margin-bottom: 30px;
        }

        .hero-features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 40px 0;
        }

        .hero-feature {
            background: rgba(255, 255, 255, 0.15);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }

        .hero-feature-icon {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .hero-feature h3 {
            font-size: 1.1em;
            margin-bottom: 8px;
        }

        .hero-feature p {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .cta-button {
            background: white;
            color: #667eea;
            padding: 15px 40px;
            border: none;
            border-radius: 50px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            display: inline-block;
            margin-top: 20px;
        }

        .cta-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        /* Main Container */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px 20px 0 0;
            box-shadow: 0 -10px 40px rgba(0,0,0,0.1);
            overflow: hidden;
            position: relative;
        }

        /* Section Headers */
        .section {
            padding: 60px 40px;
            border-bottom: 1px solid #f0f0f0;
        }

        .section:last-child {
            border-bottom: none;
        }

        .section-header {
            text-align: center;
            margin-bottom: 50px;
        }

        .section-title {
            font-size: 2.5em;
            font-weight: 300;
            color: #333;
            margin-bottom: 15px;
        }

        .section-subtitle {
            font-size: 1.2em;
            color: #666;
            max-width: 600px;
            margin: 0 auto;
        }

        /* Performance Stats Section */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 30px;
            margin-top: 40px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.1);
            transform: rotate(45deg);
        }

        .stat-card h3 {
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .stat-card p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .stat-card small {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 5px;
            display: block;
        }

        /* Demo Section */
        .demo-section {
            background: #f8f9fa;
        }

        .demo-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            margin-top: 30px;
        }

        @media (max-width: 968px) {
            .demo-grid {
                grid-template-columns: 1fr;
                gap: 30px;
            }
        }

        .demo-panel {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border: 1px solid #e9ecef;
        }

        .panel-title {
            font-size: 1.4em;
            font-weight: 600;
            margin-bottom: 20px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Language Selector */
        .language-selector-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .language-label {
            font-weight: 500;
            color: #495057;
            font-size: 14px;
            white-space: nowrap;
        }

        .language-input-wrapper {
            position: relative;
            flex-grow: 1;
        }

        .language-input {
            background: white;
            border: 1px solid #ced4da;
            border-radius: 6px;
            padding: 6px 30px 6px 12px;
            font-size: 14px;
            color: #495057;
            cursor: text;
            transition: border-color 0.2s;
            width: 100%;
            min-width: 200px;
        }

        .language-input:hover {
            border-color: #80bdff;
        }

        .language-input:focus {
            outline: none;
            border-color: #80bdff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

        .language-input-icon {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            font-size: 14px;
            color: #6c757d;
        }

        /* Text Input Styles */
        .text-container {
            position: relative;
            width: 100%;
        }

                 .text-input {
             width: 85%;
             height: 250px;
             border: 2px solid #e9ecef;
             border-radius: 12px;
             padding: 20px;
             font-size: 16px;
             font-family: inherit;
             resize: vertical;
             transition: all 0.3s;
             background: #fafafa;
             line-height: 1.5;
         }

        .text-input:focus {
            outline: none;
            border-color: #667eea;
            background: white;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .text-input.checking {
            border-color: #ffc107;
            background: #fffbf0;
        }

        .text-input.has-errors {
            border-color: #dc3545;
        }

        .text-input.no-errors {
            border-color: #28a745;
        }

                 .highlighted-text {
             position: absolute;
             top: 0;
             left: 0;
             width: 85%;
             height: 250px;
             border: 2px solid transparent;
             border-radius: 12px;
             padding: 20px;
             font-size: 16px;
             font-family: inherit;
             line-height: 1.5;
             white-space: pre-wrap;
             word-wrap: break-word;
             overflow: hidden;
             pointer-events: none;
             z-index: 3;
             background: transparent;
             color: transparent;
             box-sizing: border-box;
         }

        .error-highlight {
            background: rgba(255, 193, 7, 0.2);
            border-bottom: 2px wavy #dc3545;
            border-radius: 3px;
            cursor: pointer;
            pointer-events: all;
            color: transparent;
            position: relative;
            padding: 1px 2px;
            box-decoration-break: clone;
        }

        .error-highlight:hover {
            background: rgba(255, 193, 7, 0.35);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        /* Status Indicator */
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            margin-top: 15px;
            padding: 12px 16px;
            border-radius: 8px;
            transition: all 0.3s;
            font-weight: 500;
        }

        .status-checking {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .status-errors {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-clean {
            background: #d1edff;
            color: #0c5460;
            border: 1px solid #b8daff;
        }

        .status-ready {
            background: #f8f9fa;
            color: #6c757d;
            border: 1px solid #e9ecef;
        }

        /* Status Feedback Buttons */
        .status-feedback-buttons {
            display: flex;
            gap: 8px;
            margin-left: auto;
        }

        .status-feedback-btn {
            background: none;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            color: inherit;
        }

        .status-feedback-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .status-feedback-btn.report-issue:hover {
            background: rgba(255, 193, 7, 0.2);
            border-color: rgba(255, 193, 7, 0.5);
        }

        .status-feedback-btn.looks-good:hover {
            background: rgba(40, 167, 69, 0.2);
            border-color: rgba(40, 167, 69, 0.5);
        }

        /* Output Panel */
        .output-content {
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
        }

        .processed-text {
            background: white;
            border: 2px solid #28a745;
            border-radius: 8px;
            padding: 20px;
            font-size: 16px;
            line-height: 1.6;
        }

        /* Statistics */
        .statistics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-item {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            border: 1px solid #e9ecef;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 600;
            color: #667eea;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        /* Examples Section */
        .examples-section {
            background: white;
        }

        .example-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .example-card {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .example-card:hover {
            border-color: #667eea;
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.15);
        }

        .example-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .example-card:hover::before {
            opacity: 1;
        }

        .example-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .example-text {
            font-size: 14px;
            color: #666;
            line-height: 1.5;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }

        /* Correction Bubble */
        .correction-bubble {
            position: fixed;
            background: white;
            border: 2px solid #667eea;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            padding: 16px;
            min-width: 280px;
            max-width: 400px;
            z-index: 9999;
            display: none;
            font-size: 14px;
        }

        .correction-bubble::before {
            content: '';
            position: absolute;
            top: -10px;
            left: 20px;
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 10px solid #667eea;
        }

        .correction-bubble::after {
            content: '';
            position: absolute;
            top: -8px;
            left: 21px;
            width: 0;
            height: 0;
            border-left: 9px solid transparent;
            border-right: 9px solid transparent;
            border-bottom: 9px solid white;
        }

        .bubble-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #f0f0f0;
        }

        .bubble-type {
            font-size: 10px;
            padding: 3px 8px;
            border-radius: 12px;
            font-weight: 600;
            text-transform: uppercase;
            background: #e3f2fd;
            color: #1976d2;
        }

        .bubble-correction {
            margin-bottom: 12px;
        }

        .bubble-original {
            background: #ffebee;
            color: #c62828;
            padding: 3px 8px;
            border-radius: 4px;
            text-decoration: line-through;
            font-weight: 500;
        }

        .bubble-arrow {
            margin: 0 8px;
            color: #666;
        }

        .bubble-suggestion {
            background: #e8f5e8;
            color: #2e7d32;
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
        }

        .bubble-suggestion:hover {
            background: #c8e6c9;
        }

        .bubble-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 12px;
            padding-top: 8px;
            border-top: 1px solid #f0f0f0;
        }

        .bubble-feedback {
            display: flex;
            gap: 8px;
        }

        .feedback-btn {
            background: none;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 6px 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            transition: all 0.2s;
            font-size: 14px;
        }

        .feedback-btn:hover {
            background: #f5f5f5;
            border-color: #ccc;
        }

        .feedback-btn.thumbs-up:hover {
            background: #e8f5e8;
            border-color: #4caf50;
            color: #4caf50;
        }

        .feedback-btn.thumbs-down:hover {
            background: #ffebee;
            border-color: #f44336;
            color: #f44336;
        }

        .feedback-btn.delete:hover {
            background: #fff3e0;
            border-color: #ff9800;
            color: #ff9800;
        }

        .fix-all-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .fix-all-btn:hover {
            background: linear-gradient(135deg, #5a6fd8 0%, #6a5b9d 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 20000;
        }

        .modal {
            background: white;
            border-radius: 12px;
            padding: 30px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .modal-header {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #333;
        }

        .modal-body {
            margin-bottom: 25px;
        }

        .modal-input {
            width: 100%;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            margin-top: 10px;
            font-family: inherit;
        }

        .modal-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .modal-actions {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .modal-btn.primary {
            background: #667eea;
            color: white;
        }

        .modal-btn.primary:hover {
            background: #5a6fd8;
        }

        .modal-btn.secondary {
            background: #f5f5f5;
            color: #666;
            border: 1px solid #e0e0e0;
        }

        .modal-btn.secondary:hover {
            background: #e8e8e8;
        }

        /* Footer */
        .footer {
            background: #333;
            color: white;
            padding: 40px 20px;
            text-align: center;
        }

        .footer-content {
            max-width: 1200px;
            margin: 0 auto;
        }

        .footer h3 {
            margin-bottom: 15px;
            opacity: 0.9;
        }

        .footer p {
            opacity: 0.7;
            margin-bottom: 20px;
        }

        .footer-links {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 20px;
        }

        .footer-links a {
            color: white;
            text-decoration: none;
            opacity: 0.7;
            transition: opacity 0.3s;
        }

        .footer-links a:hover {
            opacity: 1;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .nav-links {
                display: none;
            }
            
            .hero h1 {
                font-size: 2.5em;
            }
            
            .hero .subtitle {
                font-size: 1.1em;
            }
            
            .section {
                padding: 40px 20px;
            }
            
            .section-title {
                font-size: 2em;
            }
            
            .hero-features {
                grid-template-columns: 1fr;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .example-grid {
                grid-template-columns: 1fr;
            }
            
            .footer-links {
                flex-direction: column;
                gap: 15px;
            }
        }

        /* Disable browser extensions */
        .text-input {
            -webkit-user-modify: read-write-plaintext-only;
        }

        grammarly-extension,
        grammarly-mirror,
        [data-grammarly-part] {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="nav">
        <div class="nav-content">
            <div class="nav-logo">AppenCorrect</div>
            <div class="nav-links">
                <a href="#demo">Demo</a>
                <a href="#examples">Examples</a>
                <a href="#stats">Performance</a>
                <a href="#about">About</a>
            </div>
        </div>
    </nav>

    <!-- Hero Section -->
    <section class="hero">
        <div class="hero-content">
            <h1>AI-Powered Grammar & Spell Checking</h1>
                         <p class="subtitle">Intelligent text correction with automatic multilanguage detection and support</p>
            
            <div class="hero-features">
                <div class="hero-feature">
                    <div class="hero-feature-icon">🤖</div>
                    <h3>AI-Powered</h3>
                    <p>Advanced Gemini 2.5 Flash model for intelligent corrections</p>
                </div>
                <div class="hero-feature">
                    <div class="hero-feature-icon">⚡</div>
                    <h3>Real-Time</h3>
                    <p>Instant feedback as you type with 0.8s average response time</p>
                </div>
                <div class="hero-feature">
                    <div class="hero-feature-icon">🌍</div>
                    <h3>Multi-Language</h3>
                                         <p>Automatic detection and correction for multiple languages</p>
                </div>
                <div class="hero-feature">
                    <div class="hero-feature-icon">🎯</div>
                    <h3>High Accuracy</h3>
                                         <p>High accuracy across multiple languages</p>
                </div>
            </div>
            
            <a href="#demo" class="cta-button">Try the Demo</a>
        </div>
    </section>

    <!-- Main Container -->
    <div class="container">
        
        <!-- Performance Stats Section -->
        <section id="stats" class="section">
            <div class="section-header">
                <h2 class="section-title">Performance Metrics</h2>
                <p class="section-subtitle">Real-world performance data from our AI grammar correction system</p>
            </div>
            
            <div class="stats-grid">
                                 <div class="stat-card">
                     <h3>95%+</h3>
                     <p>Average Accuracy</p>
                     <small>Across multiple languages</small>
                 </div>
                 <div class="stat-card">
                     <h3>50+</h3>
                     <p>Languages Supported</p>
                     <small>Multilingual support</small>
                 </div>
                <div class="stat-card">
                    <h3>0.80s</h3>
                    <p>Average Response</p>
                    <small>Including network overhead</small>
                </div>
                <div class="stat-card">
                    <h3>$0.0001</h3>
                    <p>Cost per Sentence</p>
                    <small>$10 per 100,000 sentences</small>
                </div>
            </div>
        </section>

        <!-- Demo Section -->
        <section id="demo" class="section demo-section">
            <div class="section-header">
                <h2 class="section-title">Interactive Demo</h2>
                <p class="section-subtitle">Experience real-time AI grammar checking. Just start typing and watch corrections appear instantly!</p>
            </div>

            <div class="demo-grid">
                <!-- Input Panel -->
                <div class="demo-panel">
                    <div class="panel-title">
                        📝 Input Your Text
                    </div>
                    
                    <div class="language-selector-container">
                        <label for="languageInput" class="language-label">Language:</label>
                        <div class="language-input-wrapper">
                            <input type="text" 
                                   id="languageInput" 
                                   class="language-input" 
                                   list="languageOptions" 
                                   value="auto" 
                                   placeholder="auto, english, fr-CA, es-MX..."
                                   title="Enter language/dialect code or select from dropdown">
                            <datalist id="languageOptions">
                                <option value="auto">🌐 Auto-detect</option>
                                <option value="english">🇺🇸 English</option>
                                <option value="french">🇫🇷 French</option>
                                <option value="spanish">🇪🇸 Spanish</option>
                                <option value="german">🇩🇪 German</option>
                                <option value="italian">🇮🇹 Italian</option>
                                <option value="en-US">🇺🇸 English (US)</option>
                                <option value="en-GB">🇬🇧 English (UK)</option>
                                <option value="en-CA">🇨🇦 English (Canada)</option>
                                <option value="en-AU">🇦🇺 English (Australia)</option>
                                <option value="fr-FR">🇫🇷 French (France)</option>
                                <option value="fr-CA">🇨🇦 French (Canada)</option>
                                <option value="es-ES">🇪🇸 Spanish (Spain)</option>
                                <option value="es-MX">🇲🇽 Spanish (Mexico)</option>
                                <option value="es-AR">🇦🇷 Spanish (Argentina)</option>
                                <option value="de-DE">🇩🇪 German (Germany)</option>
                                <option value="de-AT">🇦🇹 German (Austria)</option>
                                <option value="de-CH">🇨🇭 German (Switzerland)</option>
                                <option value="it-IT">🇮🇹 Italian (Italy)</option>
                                <option value="pt-PT">🇵🇹 Portuguese (Portugal)</option>
                                <option value="pt-BR">🇧🇷 Portuguese (Brazil)</option>
                                <option value="nl-NL">🇳🇱 Dutch (Netherlands)</option>
                                <option value="nl-BE">🇧🇪 Dutch (Belgium)</option>
                                <option value="sv-SE">🇸🇪 Swedish</option>
                                <option value="da-DK">🇩🇰 Danish</option>
                                <option value="no-NO">🇳🇴 Norwegian</option>
                                <option value="fi-FI">🇫🇮 Finnish</option>
                                <option value="ru-RU">🇷🇺 Russian</option>
                                <option value="pl-PL">🇵🇱 Polish</option>
                                <option value="cs-CZ">🇨🇿 Czech</option>
                                <option value="hu-HU">🇭🇺 Hungarian</option>
                                <option value="ro-RO">🇷🇴 Romanian</option>
                                <option value="bg-BG">🇧🇬 Bulgarian</option>
                                <option value="hr-HR">🇭🇷 Croatian</option>
                                <option value="sk-SK">🇸🇰 Slovak</option>
                                <option value="sl-SI">🇸🇮 Slovenian</option>
                                <option value="et-EE">🇪🇪 Estonian</option>
                                <option value="lv-LV">🇱🇻 Latvian</option>
                                <option value="lt-LT">🇱🇹 Lithuanian</option>
                                <option value="ja-JP">🇯🇵 Japanese</option>
                                <option value="ko-KR">🇰🇷 Korean</option>
                                <option value="zh-CN">🇨🇳 Chinese (Simplified)</option>
                                <option value="zh-TW">🇹🇼 Chinese (Traditional)</option>
                                <option value="ar-SA">🇸🇦 Arabic</option>
                                <option value="he-IL">🇮🇱 Hebrew</option>
                                <option value="hi-IN">🇮🇳 Hindi</option>
                                <option value="th-TH">🇹🇭 Thai</option>
                                <option value="vi-VN">🇻🇳 Vietnamese</option>
                                <option value="tr-TR">🇹🇷 Turkish</option>
                                <option value="uk-UA">🇺🇦 Ukrainian</option>
                                <option value="el-GR">🇬🇷 Greek</option>
                            </datalist>
                            <span class="language-input-icon">🌐</span>
                        </div>
                    </div>
                    
                    <div class="text-container">
                        <div class="highlighted-text" id="highlightedText" style="display: none;"></div>
                        <textarea 
                            class="text-input" 
                            id="inputText" 
                            placeholder="Start typing and watch AI correct your text in real-time..."
                            data-gramm="false"
                            data-gramm_editor="false"
                            data-enable-grammarly="false"
                            spellcheck="false"
                            autocomplete="off"
                            autocorrect="off"
                            autocapitalize="off"
                        ></textarea>
                    </div>
                    
                    <div class="status-indicator status-ready" id="statusIndicator">
                        <span id="statusIcon">✏️</span>
                        <span id="statusText">Ready to check your text</span>
                        <div class="status-feedback-buttons" id="statusFeedbackButtons" style="display: none;">
                            <button class="status-feedback-btn report-issue" onclick="reportMissingError()" title="Report an error we missed">
                                🤔 Report Issue
                            </button>
                            <button class="status-feedback-btn looks-good" onclick="confirmTextIsClean()" title="Confirm text is correct">
                                👍 Looks Good
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Output Panel -->
                <div class="demo-panel">
                    <div class="panel-title">
                        ✨ Corrected Text
                    </div>
                    
                    <div id="processedText" class="output-content">
                        Corrected text will appear here...
                    </div>
                    
                    <div class="statistics" id="statistics" style="display: none;">
                        <div class="stat-item">
                            <div class="stat-value" id="totalErrors">0</div>
                            <div class="stat-label">Total Errors</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="spellingErrors">0</div>
                            <div class="stat-label">Spelling</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="grammarErrors">0</div>
                            <div class="stat-label">Grammar</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="styleErrors">0</div>
                            <div class="stat-label">Style</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="responseTime">0.0s</div>
                            <div class="stat-label">Response Time</div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Examples Section -->
        <section id="examples" class="section examples-section">
            <div class="section-header">
                <h2 class="section-title">Example Texts</h2>
                <p class="section-subtitle">Click any example below to test different types of grammar and spelling errors</p>
            </div>

            <div class="example-grid">
                <div class="example-card" onclick="loadExample('spelling')">
                    <div class="example-title">
                        🔤 Spelling Errors
                    </div>
                    <div class="example-text">
                        This sentance has many speling erors that need to be corected. The dificulty lies in identifing all the misstakes automaticaly.
                    </div>
                </div>
                
                <div class="example-card" onclick="loadExample('grammar')">
                    <div class="example-title">
                        📚 Grammar Issues
                    </div>
                    <div class="example-text">
                        This are a test of grammar checking capabilities. I are going to the store tomorrow. She have been working here for many years.
                    </div>
                </div>
                
                <div class="example-card" onclick="loadExample('mixed')">
                    <div class="example-title">
                        🔄 Mixed Problems
                    </div>
                    <div class="example-text">
                        The resturant manager, who has been working their for over five years, decided to reorganize the menu because alot of costumers have been complaining.
                    </div>
                </div>
                
                <div class="example-card" onclick="loadExample('complex')">
                    <div class="example-title">
                        🧠 Complex Text
                    </div>
                    <div class="example-text">
                        Artificial inteligence is revolutionizing how we aproach language procesing and error corection. Machine learning algoritms can now identifiy contextual mistakes.
                    </div>
                </div>
                
                <div class="example-card" onclick="loadExample('homophones')">
                    <div class="example-title">
                        🎭 Homophones Demo
                    </div>
                    <div class="example-text">
                        Your going to loose you're job if you effected the weather forecast. Their house is located wear the capitol building stands, and its important no the difference.
                    </div>
                </div>
                
                <div class="example-card" onclick="loadExample('professional')">
                    <div class="example-title">
                        💼 Professional Text
                    </div>
                    <div class="example-text">
                        The companys quartly report shows there have been signifigant improvments in there perfomance metrics. This acheivement is the result of there teams dedication and there comitment to excelence. However, they're still faceing some chalenges in there market postion and will need to adress these isues in the comming fiscal year.
                    </div>
                </div>
            </div>
        </section>

        <!-- About Section -->
        <section id="about" class="section">
            <div class="section-header">
                <h2 class="section-title">About AppenCorrect</h2>
                <p class="section-subtitle">Powered by cutting-edge AI technology for superior grammar and spell checking</p>
            </div>
            
            <div class="hero-features">
                <div class="hero-feature" style="background: #f8f9fa; color: #333;">
                    <div class="hero-feature-icon" style="color: #667eea;">🚀</div>
                    <h3>Advanced AI Technology</h3>
                    <p>Built on Google's Gemini 2.5 Flash model with specialized training for grammar correction</p>
                </div>
                <div class="hero-feature" style="background: #f8f9fa; color: #333;">
                    <div class="hero-feature-icon" style="color: #667eea;">🔧</div>
                    <h3>Customizable Options</h3>
                    <p>Fine-tune correction sensitivity and language preferences to match your writing style</p>
                </div>
                <div class="hero-feature" style="background: #f8f9fa; color: #333;">
                    <div class="hero-feature-icon" style="color: #667eea;">🔒</div>
                    <h3>Privacy Focused</h3>
                    <p>Your text is processed securely with no permanent storage of personal content</p>
                </div>
                <div class="hero-feature" style="background: #f8f9fa; color: #333;">
                    <div class="hero-feature-icon" style="color: #667eea;">⚙️</div>
                    <h3>API Integration</h3>
                    <p>Easy integration into your applications with <a href="/api-docs" style="color: #667eea; text-decoration: underline;">comprehensive REST API documentation</a></p>
                </div>
            </div>
        </section>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <div class="footer-content">
            <h3>AppenCorrect</h3>
            <p>AI-powered grammar and spell checking for the modern world</p>
            <div class="footer-links">
                <a href="#demo">Demo</a>
                <a href="#examples">Examples</a>
                <a href="#stats">Performance</a>
                <a href="#about">About</a>
                <a href="/api-docs">API Docs</a>
                <a href="/api-management">API Management</a>
                <a href="/login">🔐 Appen Login</a>
                <a href="/register">✨ Register</a>
            </div>
            <p style="font-size: 0.9em; margin-top: 20px;">© 2025 Appen. Powered by Gemini AI.</p>
        </div>
    </footer>

    <!-- Correction Bubble -->
    <div class="correction-bubble" id="correctionBubble" 
         onmouseenter="isHoveringBubble = true; clearTimeout(hoverTimeout);" 
         onmouseleave="isHoveringBubble = false; hideHoverBubble();">
        <div class="bubble-header">
            <span class="bubble-type" id="bubbleType">GRAMMAR</span>
        </div>
        <div class="bubble-correction">
            <span class="bubble-original" id="bubbleOriginal">original</span>
            <span class="bubble-arrow">→</span>
            <span class="bubble-suggestion" id="bubbleSuggestion" onclick="applyCorrectionFromBubble()">suggestion</span>
        </div>
        <div class="bubble-actions">
            <div class="bubble-feedback">
                <button class="feedback-btn thumbs-up" onclick="submitFeedback('positive')" title="Good suggestion">
                    👍
                </button>
                <button class="feedback-btn thumbs-down" onclick="submitFeedback('negative')" title="Wrong suggestion">
                    👎
                </button>
                <button class="feedback-btn delete" onclick="deleteBubble()" title="Ignore this error">
                    🗑️
                </button>
            </div>
            <button class="fix-all-btn" onclick="fixAllErrors()" title="Apply all corrections">
                ✨ Fix All
            </button>
        </div>
    </div>

    <!-- Feedback Modal -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal">
            <div class="modal-header" id="modalHeader">Provide Correct Version</div>
            <div class="modal-body">
                <p id="modalDescription">You indicated this suggestion is wrong. What should it be instead?</p>
                <div id="modalCorrectionContext" style="margin: 12px 0;">
                    <strong>Original:</strong> <span id="modalOriginal"></span><br>
                    <strong>AI Suggestion:</strong> <span id="modalSuggestion"></span>
                </div>
                <div id="modalMissingErrorContext" style="margin: 12px 0; display: none;">
                    <p>Please describe the error you noticed that we missed:</p>
                    <textarea id="modalSelectedText" rows="3" style="width: 100%; margin-bottom: 10px;" placeholder="Paste or type the text with the error..."></textarea>
                </div>
                <input type="text" class="modal-input" id="modalCorrection" placeholder="Enter the correct version (or leave blank to just report as wrong)..." />
            </div>
            <div class="modal-actions">
                <button class="modal-btn secondary" onclick="closeModal()">Cancel</button>
                <button class="modal-btn primary" onclick="submitCorrection()">Submit Feedback</button>
            </div>
        </div>
    </div>

    <script>
        const examples = {
            spelling: "This sentance has many speling erors that need to be corected. The dificulty lies in identifing all the misstakes automaticaly.",
            grammar: "This are a test of grammar checking capabilities. I are going to the store tomorrow. She have been working here for many years.",
            mixed: "The resturant manager, who has been working their for over five years, decided to reorganize the menu because alot of costumers have been complaining about the food quality and the slow service, and he beleives that this changes will help improve there overall dining experiance.",
            complex: "Artificial inteligence is revolutionizing how we aproach language procesing and error corection. Machine learning algoritms can now identifiy contextual mistakes that traditional spell checkers would miss, making them invalueable tools for writters and editors who want to ensure there work meets the highest standards of clarity and profesionalism.",
            homophones: "Your going to loose you're job if you effected the weather forecast. Their house is located wear the capitol building stands, and its important no the difference. The companie's profits has been effected by the new regulations, so there considering a merger with there competitors.",
            professional: "The companys quartly report shows there have been signifigant improvments in there perfomance metrics. This acheivement is the result of there teams dedication and there comitment to excelence. However, they're still faceing some chalenges in there market postion and will need to adress these isues in the comming fiscal year."
        };

        // Real-time checking variables
        let checkingTimeout;
        let isChecking = false;
        let lastCheckedText = '';
        let currentCorrections = [];
        let currentBubbleCorrection = null;
        let hoverTimeout;
        let isHoveringBubble = false;

        function loadExample(type) {
            const inputText = document.getElementById('inputText');
            inputText.value = examples[type];
            updateTextOverlay();
            handleTextChange();
            
            // Smooth scroll to demo section
            document.getElementById('demo').scrollIntoView({ 
                behavior: 'smooth',
                block: 'center'
            });
        }

        // Smooth scrolling for navigation links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Smart debounced text checking function
        function handleTextChange() {
            const inputText = document.getElementById('inputText');
            const fullText = inputText.value;
            const trimmedText = fullText.trim();
            
            clearTimeout(checkingTimeout);
            hideBubble();
            
            if (trimmedText.length < 5) {
                if (trimmedText.length === 0) {
                    updateStatus('ready', '✏️', 'Ready to check your text');
                    clearTextStyling();
                    clearOverlayHighlights();
                }
                return;
            }
            
            // Skip if text hasn't changed (but be more lenient with whitespace)
            if (fullText.trim() === lastCheckedText.trim()) {
                console.log('Text unchanged, skipping check - preserving existing highlights');
                return;
            }
            
            // Only clear highlights when text has actually changed meaningfully
            updateTextOverlay();
            
            console.log('Text changed, scheduling check...');
            console.log('Previous:', lastCheckedText.substring(0, 50) + '...');
            console.log('Current:', fullText.substring(0, 50) + '...');
            
            updateStatus('checking', '🔄', 'Checking grammar...');
            inputText.classList.add('checking');
            
            // Smart delay: longer delay if user appears to be actively typing
            const delay = getSmartDelay(fullText);
            
            checkingTimeout = setTimeout(() => {
                // Double-check the text hasn't changed during the delay
                if (inputText.value === fullText) {
                    checkTextRealtime(fullText);
                }
            }, delay);
        }

        // Calculate smart delay based on text patterns
        function getSmartDelay(text) {
            // Base delay
            let delay = 1500;
            
            const trimmedText = text.trim();
            const lastChar = trimmedText.slice(-1);
            
            // FAST CHECK: If text ends with sentence-ending punctuation, check quickly
            if (/[.!?;]/.test(lastChar)) {
                return 800; // Very fast for complete sentences
            }
            
            // FAST CHECK: If text ends with comma or colon, also reasonably fast
            if (/[,:)}\]]/.test(lastChar)) {
                return 1200; // Fast for phrase completion
            }
            
            // If we recently checked similar text, use shorter delay for additions
            if (lastCheckedText && text.startsWith(lastCheckedText.trim())) {
                const addition = text.slice(lastCheckedText.trim().length).trim();
                if (addition.length > 0 && addition.length < 20) {
                    // Small addition after previous check - faster check
                    delay = 1000;
                }
            }
            
            // SLOW CHECK: If text ends with incomplete word (no space/punctuation), wait longer
            const endsWithWordChar = /[a-zA-Z0-9]/.test(lastChar);
            const hasRecentSpace = text.slice(-10).includes(' ');
            
            if (endsWithWordChar && !hasRecentSpace) {
                // User might still be typing a word, wait longer
                delay = Math.max(delay, 2500);
            }
            
            // SLOW CHECK: If text is very short, user likely still composing, wait longer
            if (trimmedText.length < 15) {
                delay = Math.max(delay, 2000);
            }
            
            // SLOW CHECK: If text ends with common typing patterns, wait longer
            if (/\b[a-z]+$/.test(trimmedText)) {
                // Ends with lowercase word - likely still typing
                delay = Math.max(delay, 2500);
            }
            
            return delay;
        }

        // Clear any previous corrections when text changes
        function updateTextOverlay() {
            clearOverlayHighlights();
        }

        async function checkTextRealtime(text) {
            if (isChecking) return;
            
            console.log('Starting checkTextRealtime with text:', text.substring(0, 50) + '...');
            isChecking = true;
            // Don't set lastCheckedText yet - wait until check completes
            
            const startTime = performance.now();
            
            try {
                const options = {
                    ai_first_mode: true
                };

                // Get selected language from input field
                const selectedLanguage = document.getElementById('languageInput').value.trim() || 'auto';

                console.log('Making API call to /demo/check...');
                const response = await fetch('/demo/check', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        text: text,
                        language: selectedLanguage,
                        options: options
                    })
                });

                console.log('API response status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API error response:', errorText);
                    throw new Error(`HTTP error! status: ${response.status} - ${errorText}`);
                }

                const data = await response.json();
                const endTime = performance.now();
                const responseTime = (endTime - startTime) / 1000;
                
                console.log('API response data:', data);
                handleRealtimeResults(data, responseTime, text);

            } catch (error) {
                console.error('Error in checkTextRealtime:', error);
                updateStatus('ready', '⚠️', 'Check failed - try again');
            } finally {
                console.log('Cleaning up checkTextRealtime');
                isChecking = false;
                clearTextStyling();
                
                // Check if text changed while we were processing
                const currentText = document.getElementById('inputText').value;
                if (currentText !== text && currentText.trim().length >= 5) {
                    console.log('Text changed during check, scheduling re-check...');
                    // Schedule another check after a short delay
                    setTimeout(() => handleTextChange(), 500);
                }
            }
        }

        // Handle real-time results  
        function handleRealtimeResults(data, responseTime, checkedText) {
            console.log('Received API response with', (data.corrections || []).length, 'corrections');
            
            // Mark the original checked text as processed
            lastCheckedText = checkedText;
            currentCorrections = data.corrections || [];
            
            if (currentCorrections.length > 0) {
                updateStatus('errors', '⚠️', `${currentCorrections.length} correction${currentCorrections.length > 1 ? 's' : ''} found`);
                highlightErrors(currentCorrections);
                document.getElementById('inputText').classList.add('has-errors');
            } else {
                updateStatus('clean', '✅', 'Text looks great!');
                clearOverlayHighlights();
                document.getElementById('inputText').classList.add('no-errors');
            }
            
            // Update corrected text display
            const processedTextDiv = document.getElementById('processedText');
            processedTextDiv.innerHTML = `
                <div class="processed-text">
                    ${data.processed_text || data.original_text}
                </div>
            `;
            
            // Calculate and display statistics
            updateStatistics(currentCorrections, responseTime);
        }
        
        // Update statistics display
        function updateStatistics(corrections, responseTime) {
            const totalErrors = corrections.length;
            let spellingErrors = 0;
            let grammarErrors = 0;
            let styleErrors = 0;
            
            corrections.forEach(correction => {
                switch(correction.type.toLowerCase()) {
                    case 'spelling':
                        spellingErrors++;
                        break;
                    case 'grammar':
                        grammarErrors++;
                        break;
                    case 'style':
                        styleErrors++;
                        break;
                }
            });
            
            // Update DOM elements
            document.getElementById('totalErrors').textContent = totalErrors;
            document.getElementById('spellingErrors').textContent = spellingErrors;
            document.getElementById('grammarErrors').textContent = grammarErrors;
            document.getElementById('styleErrors').textContent = styleErrors;
            document.getElementById('responseTime').textContent = `${responseTime.toFixed(2)}s`;
            
            // Show statistics if there are corrections or if we have response time data
            if (totalErrors > 0 || responseTime > 0) {
                document.getElementById('statistics').style.display = 'grid';
            } else {
                document.getElementById('statistics').style.display = 'none';
            }
        }

        function highlightErrors(corrections) {
            const inputText = document.getElementById("inputText");
            const highlightedText = document.getElementById("highlightedText");
            let text = inputText.value;
            
            if (!corrections || corrections.length === 0) {
                highlightedText.style.display = 'none';
                return;
            }
            
            // Perfect font matching
            const textareaStyle = window.getComputedStyle(inputText);
            const fontProperties = [
                'fontFamily', 'fontSize', 'fontWeight', 'fontStyle', 'fontVariant',
                'fontStretch', 'lineHeight', 'letterSpacing', 'wordSpacing',
                'textIndent', 'textAlign', 'textTransform', 'textRendering',
                'fontKerning', 'fontVariantLigatures', 'fontVariantCaps',
                'fontVariantNumeric', 'fontVariantPosition', 'fontFeatureSettings',
                'fontVariationSettings', 'textSizeAdjust', 'writingMode'
            ];
            
            fontProperties.forEach(prop => {
                if (textareaStyle[prop]) {
                    highlightedText.style[prop] = textareaStyle[prop];
                }
            });
            
            highlightedText.style.webkitFontSmoothing = textareaStyle.webkitFontSmoothing || 'auto';
            highlightedText.style.mozOsxFontSmoothing = textareaStyle.mozOsxFontSmoothing || 'auto';
            highlightedText.style.fontSmooth = textareaStyle.fontSmooth || 'auto';
            
            highlightedText.style.padding = textareaStyle.padding;
            highlightedText.style.border = '2px solid transparent';
            highlightedText.style.boxSizing = textareaStyle.boxSizing;
            
            // Use position data directly instead of indexOf to find error positions
            const errorPositions = [];
            
            corrections.forEach((correction, index) => {
                if (correction.position) {
                    const start = correction.position[0];
                    const end = correction.position[1];
                    const textAtPosition = text.substring(start, end);
                    
                    // Verify the text at the position matches the original (sanity check)
                    if (textAtPosition === correction.original) {
                        // Check for overlaps with existing error positions
                        const isOverlap = errorPositions.some(existing => 
                            (start >= existing.start && start < existing.end) ||
                            (end > existing.start && end <= existing.end) ||
                            (start <= existing.start && end >= existing.end)
                        );
                        
                        if (!isOverlap) {
                            errorPositions.push({
                                start: start,
                                end: end,
                                correction: correction,
                                index: index
                            });
                        }
                    } else {
                        // Fallback to indexOf if position data doesn't match (text may have changed)
                        const fallbackPos = text.indexOf(correction.original);
                        if (fallbackPos !== -1) {
                            const fallbackEnd = fallbackPos + correction.original.length;
                            const isOverlap = errorPositions.some(existing => 
                                (fallbackPos >= existing.start && fallbackPos < existing.end) ||
                                (fallbackEnd > existing.start && fallbackEnd <= existing.end)
                            );
                            
                            if (!isOverlap) {
                                errorPositions.push({
                                    start: fallbackPos,
                                    end: fallbackEnd,
                                    correction: correction,
                                    index: index
                                });
                            }
                        }
                    }
                } else {
                    // Fallback for corrections without position data
                    let searchFrom = 0;
                    
                    while (searchFrom < text.length) {
                        const pos = text.indexOf(correction.original, searchFrom);
                        if (pos === -1) break;
                        
                        const isOverlap = errorPositions.some(existing => 
                            (pos >= existing.start && pos < existing.end) ||
                            (pos + correction.original.length > existing.start && pos + correction.original.length <= existing.end)
                        );
                        
                        if (!isOverlap) {
                            errorPositions.push({
                                start: pos,
                                end: pos + correction.original.length,
                                correction: correction,
                                index: index
                            });
                            break;
                        }
                        
                        searchFrom = pos + 1;
                    }
                }
            });
            
            errorPositions.sort((a, b) => b.start - a.start);
            
            // Simple and reliable approach: work with escaped HTML from the start
            let htmlContent = escapeHtml(text);
            
            // Apply highlights from right to left to avoid position shifts
            errorPositions.forEach(errorPos => {
                const correction = errorPos.correction;
                
                // Calculate positions in the escaped HTML
                const beforeText = text.substring(0, errorPos.start);
                const originalText = text.substring(errorPos.start, errorPos.end);
                const afterText = text.substring(errorPos.end);
                
                const beforeEscaped = escapeHtml(beforeText);
                const originalEscaped = escapeHtml(originalText);
                const afterEscaped = escapeHtml(afterText);
                
                const startPosInHtml = beforeEscaped.length;
                const endPosInHtml = startPosInHtml + originalEscaped.length;
                
                const highlightedWord = `<span class="error-highlight" 
                    data-original="${escapeHtml(correction.original)}"
                    data-suggestion="${escapeHtml(correction.suggestion)}"
                    data-type="${escapeHtml(correction.type)}"
                    data-confidence="${correction.confidence}"
                    data-index="${errorPos.index}"
                    data-start="${errorPos.start}"
                    data-end="${errorPos.end}"
                    title="Click to change '${escapeHtml(correction.original)}' to '${escapeHtml(correction.suggestion)}'"
                    onmouseenter="showHoverBubble(event)"
                    onmouseleave="hideHoverBubble()"
                    onclick="applyCorrection(event)">${originalEscaped}</span>`;
                
                // Replace the text at the calculated HTML positions
                htmlContent = htmlContent.substring(0, startPosInHtml) + highlightedWord + htmlContent.substring(endPosInHtml);
            });
            
            highlightedText.innerHTML = htmlContent;
            highlightedText.style.display = 'block';
            
            highlightedText.offsetHeight;
            
            setTimeout(() => {
                highlightedText.scrollTop = inputText.scrollTop;
                highlightedText.scrollLeft = inputText.scrollLeft;
            }, 0);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Hover bubble functions
        function showHoverBubble(event) {
            clearTimeout(hoverTimeout);
            
            const span = event.target;
            const correction = {
                original: span.getAttribute("data-original"),
                suggestion: span.getAttribute("data-suggestion"),
                type: span.getAttribute("data-type"),
                confidence: parseFloat(span.getAttribute("data-confidence"))
            };
            
            const bubble = document.getElementById("correctionBubble");
            const bubbleType = document.getElementById("bubbleType");
            const bubbleOriginal = document.getElementById("bubbleOriginal");
            const bubbleSuggestion = document.getElementById("bubbleSuggestion");
            
            bubbleType.textContent = correction.type.toUpperCase();
            bubbleType.className = `bubble-type type-${correction.type}`;
            bubbleOriginal.textContent = correction.original;
            bubbleSuggestion.textContent = correction.suggestion;
            
            const rect = span.getBoundingClientRect();
            
            let left = rect.left;
            let top = rect.bottom + 5;
            
            const bubbleWidth = 300;
            if (left + bubbleWidth > window.innerWidth) {
                left = window.innerWidth - bubbleWidth - 20;
            }
            if (left < 10) left = 10;
            
            bubble.style.left = `${left}px`;
            bubble.style.top = `${top}px`;
            bubble.style.position = 'fixed';
            bubble.style.display = "block";
            window.currentHoverCorrection = correction;
        }

        function hideHoverBubble() {
            hoverTimeout = setTimeout(() => {
                const bubble = document.getElementById("correctionBubble");
                const isOverBubble = bubble.matches(":hover");
                const isOverHighlight = document.querySelector(".error-highlight:hover");
                
                if (!isOverBubble && !isOverHighlight && !isHoveringBubble) {
                    bubble.style.display = "none";
                    window.currentHoverCorrection = null;
                }
            }, 300);
        }

        function hideBubble() {
            document.getElementById('correctionBubble').style.display = 'none';
            window.currentHoverCorrection = null;
        }

        function applyCorrection(event) {
            event.stopPropagation();
            const span = event.target;
            const original = span.getAttribute("data-original");
            const suggestion = span.getAttribute("data-suggestion");
            const startPos = parseInt(span.getAttribute("data-start"));
            const endPos = parseInt(span.getAttribute("data-end"));
            
            const inputText = document.getElementById("inputText");
            const currentText = inputText.value;
            
            // Apply correction using precise position (more reliable than string replace)
            const beforeText = currentText.substring(0, startPos);
            const afterText = currentText.substring(endPos);
            const newText = beforeText + suggestion + afterText;
            
            inputText.value = newText;
            
            console.log(`Applied correction at position ${startPos}-${endPos}: "${original}" → "${suggestion}"`);
            console.log(`Text changed from "${original}" to "${suggestion}"`);
            
            // Calculate the length difference to update positions
            const lengthDiff = suggestion.length - original.length;
            
            // Remove the applied correction and any problematic overlapping/conflicting corrections
            currentCorrections = currentCorrections.filter(correction => {
                // Remove correction if it matches the exact position and text
                if (correction.position && correction.position[0] === startPos && correction.position[1] === endPos) {
                    console.log(`Removing applied correction: "${correction.original}" → "${correction.suggestion}" at ${startPos}-${endPos}`);
                    return false; // Remove this correction
                }
                
                // Also handle corrections without position data (fallback)
                if (!correction.position && correction.original === original && correction.suggestion === suggestion) {
                    console.log(`Removing applied correction (no position): "${correction.original}" → "${correction.suggestion}"`);
                    return false; // Remove this correction
                }
                
                // Remove reverse corrections that would affect the newly inserted text at this specific position
                // Only remove if it's a reverse correction AND it would affect the same or overlapping text
                if (correction.original === suggestion && correction.suggestion === original && correction.position) {
                    const corrStart = correction.position[0];
                    const corrEnd = correction.position[1];
                    const newTextStart = startPos;
                    const newTextEnd = startPos + suggestion.length;
                    
                    // Check if the reverse correction overlaps with our newly inserted text
                    const overlaps = (corrStart < newTextEnd && corrEnd > newTextStart);
                    
                    if (overlaps) {
                        console.log(`Removing overlapping reverse correction: "${correction.original}" → "${correction.suggestion}" at ${corrStart}-${corrEnd} (overlaps with applied correction at ${newTextStart}-${newTextEnd})`);
                        return false; // Remove this reverse correction
                    }
                }
                
                return true; // Keep this correction
            });
            
            // Update positions of remaining corrections due to text length change
            if (lengthDiff !== 0) {
                currentCorrections.forEach(correction => {
                    if (correction.position && correction.position[0] > endPos) {
                        correction.position[0] += lengthDiff;
                        correction.position[1] += lengthDiff;
                        console.log(`Updated correction position: "${correction.original}" now at ${correction.position[0]}-${correction.position[1]}`);
                    }
                });
            }
            
            highlightErrors(currentCorrections);
            
            if (currentCorrections.length > 0) {
                updateStatus('errors', '⚠️', `${currentCorrections.length} correction${currentCorrections.length > 1 ? 's' : ''} found`);
            } else {
                updateStatus('clean', '✅', 'Text looks great!');
                document.getElementById('inputText').classList.remove('has-errors');
                document.getElementById('inputText').classList.add('no-errors');
            }
            
            const processedTextDiv = document.getElementById('processedText');
            processedTextDiv.innerHTML = `<div class="processed-text">${newText}</div>`;
            
            // Update lastCheckedText to prevent automatic reprocessing
            lastCheckedText = newText;
            
            console.log("Remaining corrections:", currentCorrections.length);
            console.log("Updated correction list:", currentCorrections.map(c => ({ original: c.original, suggestion: c.suggestion, position: c.position })));
        }

        function clearOverlayHighlights() {
            const highlightedText = document.getElementById('highlightedText');
            if (highlightedText) {
                highlightedText.style.display = 'none';
                highlightedText.innerHTML = '';
            }
        }

        function applyCorrectionFromBubble() {
            const correction = window.currentHoverCorrection;
            if (!correction) {
                console.log('No current correction to apply');
                return;
            }
            
            const inputText = document.getElementById('inputText');
            const currentText = inputText.value;
            
            // Use position-based replacement if available
            let newText;
            let appliedStart, appliedEnd;
            if (correction.position) {
                appliedStart = correction.position[0];
                appliedEnd = correction.position[1];
                const beforeText = currentText.substring(0, appliedStart);
                const afterText = currentText.substring(appliedEnd);
                newText = beforeText + correction.suggestion + afterText;
                
                console.log(`Applied correction from bubble at position ${appliedStart}-${appliedEnd}: "${correction.original}" → "${correction.suggestion}"`);
            } else {
                // Fallback to string replace for corrections without position
                newText = currentText.replace(correction.original, correction.suggestion);
                console.log(`Applied correction from bubble (no position): "${correction.original}" → "${correction.suggestion}"`);
            }
            
            inputText.value = newText;
            
            // Remove the applied correction and any problematic overlapping/conflicting corrections
            currentCorrections = currentCorrections.filter(c => {
                // Remove correction if it matches the exact position and text
                if (c.position && correction.position && 
                    c.position[0] === correction.position[0] && c.position[1] === correction.position[1]) {
                    console.log(`Removing applied correction from bubble: "${c.original}" → "${c.suggestion}" at ${c.position[0]}-${c.position[1]}`);
                    return false; // Remove this correction
                }
                
                // Also handle corrections without position data (fallback)
                if (!c.position && !correction.position && 
                    c.original === correction.original && c.suggestion === correction.suggestion) {
                    console.log(`Removing applied correction from bubble (no position): "${c.original}" → "${c.suggestion}"`);
                    return false; // Remove this correction
                }
                
                // Remove reverse corrections that would affect the newly inserted text at this specific position
                if (c.original === correction.suggestion && c.suggestion === correction.original && c.position && correction.position) {
                    const corrStart = c.position[0];
                    const corrEnd = c.position[1];
                    const newTextStart = correction.position[0];
                    const newTextEnd = correction.position[0] + correction.suggestion.length;
                    
                    // Check if the reverse correction overlaps with our newly inserted text
                    const overlaps = (corrStart < newTextEnd && corrEnd > newTextStart);
                    
                    if (overlaps) {
                        console.log(`Removing overlapping reverse correction from bubble: "${c.original}" → "${c.suggestion}" at ${corrStart}-${corrEnd}`);
                        return false; // Remove this reverse correction
                    }
                }
                
                return true; // Keep this correction
            });
            
            // Update positions of remaining corrections if we applied a position-based correction
            if (correction.position) {
                const lengthDiff = correction.suggestion.length - correction.original.length;
                if (lengthDiff !== 0) {
                    currentCorrections.forEach(c => {
                        if (c.position && c.position[0] > correction.position[1]) {
                            c.position[0] += lengthDiff;
                            c.position[1] += lengthDiff;
                        }
                    });
                }
            }
            
            highlightErrors(currentCorrections);
            
            if (currentCorrections.length > 0) {
                updateStatus('errors', '⚠️', `${currentCorrections.length} correction${currentCorrections.length > 1 ? 's' : ''} found`);
            } else {
                updateStatus('clean', '✅', 'Text looks great!');
                document.getElementById('inputText').classList.remove('has-errors');
                document.getElementById('inputText').classList.add('no-errors');
            }
            
            const processedTextDiv = document.getElementById('processedText');
            processedTextDiv.innerHTML = `<div class="processed-text">${newText}</div>`;
            
            hideBubble();
        }

        function submitFeedback(type) {
            const correction = window.currentBubbleCorrection || window.currentHoverCorrection;
            if (!correction) {
                console.log('No current correction for feedback');
                return;
            }
            
            if (type === 'positive') {
                console.log('Positive feedback for:', correction);
                
                // Send positive feedback to backend
                sendFeedbackToAPI({
                    original: correction.original,
                    ai_suggestion: correction.suggestion,
                    feedback_type: 'positive',
                    correction_type: correction.type,
                    confidence: correction.confidence || 0.5
                });
                
                const inputText = document.getElementById('inputText');
                const currentText = inputText.value;
                const newText = currentText.replace(correction.original, correction.suggestion);
                
                inputText.value = newText;
                
                currentCorrections = currentCorrections.filter(c => 
                    c.original !== correction.original || c.suggestion !== correction.suggestion
                );
                
                highlightErrors(currentCorrections);
                
                if (currentCorrections.length > 0) {
                    updateStatus('errors', '⚠️', `${currentCorrections.length} correction${currentCorrections.length > 1 ? 's' : ''} found`);
                } else {
                    updateStatus('clean', '✅', 'Text looks great!');
                    document.getElementById('inputText').classList.remove('has-errors');
                    document.getElementById('inputText').classList.add('no-errors');
                }
                
                const processedTextDiv = document.getElementById('processedText');
                processedTextDiv.innerHTML = `<div class="processed-text">${newText}</div>`;
                
                hideBubble();
            } else if (type === 'negative') {
                // Don't send feedback immediately - wait for modal submission
                // This prevents double feedback logging
                window.currentBubbleCorrection = correction;
                openFeedbackModal();
            }
        }

        function deleteBubble() {
            const correction = window.currentHoverCorrection;
            if (!correction) {
                console.log('No current correction to delete');
                return;
            }
            
            currentCorrections = currentCorrections.filter(c => 
                c.original !== correction.original || c.suggestion !== correction.suggestion
            );
            
            highlightErrors(currentCorrections);
            
            if (currentCorrections.length > 0) {
                updateStatus('errors', '⚠️', `${currentCorrections.length} correction${currentCorrections.length > 1 ? 's' : ''} found`);
            } else {
                updateStatus('clean', '✅', 'Text looks great!');
                clearOverlayHighlights();
            }
            
            // Update lastCheckedText to prevent automatic reprocessing
            lastCheckedText = newText;
            
            hideBubble();
        }

        function fixAllErrors() {
            if (!currentCorrections || currentCorrections.length === 0) {
                console.log('No corrections to apply');
                return;
            }
            
            const inputText = document.getElementById('inputText');
            let currentText = inputText.value;
            let appliedCount = 0;
            
            // Sort corrections by position (highest position first) to avoid position shifts
            // Filter out corrections without valid positions
            const validCorrections = currentCorrections.filter(c => c.position && c.position.length >= 2);
            const sortedCorrections = [...validCorrections].sort((a, b) => {
                return b.position[0] - a.position[0]; // Sort by start position, highest first
            });
            
            console.log('Applying corrections in position order:', sortedCorrections.map(c => ({
                original: c.original,
                suggestion: c.suggestion,
                position: c.position
            })));
            
            // Apply corrections from right to left using exact positions
            sortedCorrections.forEach(correction => {
                const startPos = correction.position[0];
                const endPos = correction.position[1];
                const textAtPosition = currentText.substring(startPos, endPos);
                
                console.log(`Applying correction at [${startPos}, ${endPos}]: "${textAtPosition}" -> "${correction.suggestion}"`);
                
                // Verify the text at position matches what we expect to replace
                if (textAtPosition === correction.original) {
                    // Replace text at exact position
                    currentText = currentText.substring(0, startPos) + correction.suggestion + currentText.substring(endPos);
                    appliedCount++;
                } else {
                    console.warn(`Text mismatch at position [${startPos}, ${endPos}]: expected "${correction.original}", found "${textAtPosition}"`);
                }
            });
            
            inputText.value = currentText;
            
            currentCorrections = [];
            clearOverlayHighlights();
            
            updateStatus('clean', '✅', `Fixed ${appliedCount} error${appliedCount > 1 ? 's' : ''}! Text looks great!`);
            document.getElementById('inputText').classList.remove('has-errors');
            document.getElementById('inputText').classList.add('no-errors');
            
            const processedTextDiv = document.getElementById('processedText');
            processedTextDiv.innerHTML = `<div class="processed-text">${currentText}</div>`;
            
            hideBubble();
            
            // Set lastCheckedText to the corrected text to prevent immediate reprocessing
            lastCheckedText = currentText;
            
            console.log(`Applied ${appliedCount} corrections automatically using position-based replacement`);
        }

        function openFeedbackModal() {
            const correction = window.currentBubbleCorrection || window.currentHoverCorrection;
            if (!correction) {
                console.log('No correction available for feedback modal');
                return;
            }
            
            console.log('Opening feedback modal for:', correction);
            
            // Configure modal for correction feedback (existing functionality)
            document.getElementById('modalHeader').textContent = 'Provide Correct Version';
            document.getElementById('modalDescription').textContent = 'You indicated this suggestion is wrong. What should it be instead?';
            document.getElementById('modalCorrectionContext').style.display = 'block';
            document.getElementById('modalMissingErrorContext').style.display = 'none';
            
            document.getElementById('modalOriginal').textContent = correction.original;
            document.getElementById('modalSuggestion').textContent = correction.suggestion;
            document.getElementById('modalCorrection').value = '';
            document.getElementById('modalCorrection').placeholder = 'Enter the correct version (or leave blank to just report as wrong)...';
            document.getElementById('modalOverlay').style.display = 'flex';
            
            window.currentBubbleCorrection = correction;
            window.currentModalType = 'correction_feedback';
            
            setTimeout(() => {
                document.getElementById('modalCorrection').focus();
            }, 100);
        }

        // New functions for missing error feedback
        function reportMissingError() {
            console.log('Opening missing error report modal');
            
            // Configure modal for missing error feedback (new functionality)
            document.getElementById('modalHeader').textContent = 'Report Missing Error';
            document.getElementById('modalDescription').textContent = 'Help us improve by reporting errors we missed:';
            document.getElementById('modalCorrectionContext').style.display = 'none';
            document.getElementById('modalMissingErrorContext').style.display = 'block';
            
            // Clear and set up form fields
            document.getElementById('modalSelectedText').value = '';
            document.getElementById('modalCorrection').value = '';
            document.getElementById('modalCorrection').placeholder = 'What should the correct text be?';
            document.getElementById('modalOverlay').style.display = 'flex';
            
            window.currentModalType = 'missing_error';
            
            setTimeout(() => {
                document.getElementById('modalSelectedText').focus();
            }, 100);
        }

        function confirmTextIsClean() {
            console.log('User confirmed text is clean');
            
            // Send positive feedback for no corrections found
            const inputText = document.getElementById('inputText').value;
            
            sendFeedbackToAPI({
                original: inputText,
                ai_suggestion: 'no_corrections_suggested',
                feedback_type: 'text_confirmed_clean',
                correction_type: 'general',
                confidence: 1.0
            });
            
            // Show brief success message
            updateStatus('clean', '✅', 'Thanks for confirming! Text looks great!');
            setTimeout(() => {
                updateStatus('clean', '✅', 'Text looks great!');
            }, 2000);
        }

        function closeModal() {
            document.getElementById('modalOverlay').style.display = 'none';
        }

                 function submitCorrection() {
             const modalType = window.currentModalType || 'correction_feedback';
             const userCorrection = document.getElementById('modalCorrection').value.trim();
             
             if (modalType === 'missing_error') {
                 // Handle missing error report
                 const selectedText = document.getElementById('modalSelectedText').value.trim();
                 
                 if (!selectedText && !userCorrection) {
                     alert('Please provide either the incorrect text or the correction (or both)');
                     return;
                 }
                 
                 console.log('Missing error report being sent:', {
                     selectedText: selectedText,
                     userCorrection: userCorrection,
                     fullText: document.getElementById('inputText').value
                 });
                 
                 // Send missing error feedback to backend
                 sendFeedbackToAPI({
                     original: selectedText || 'Full text scan requested',
                     ai_suggestion: 'no_corrections_suggested',
                     user_correction: userCorrection || 'Error reported without specific correction',
                     feedback_type: 'missing_error',
                     correction_type: 'missed_error',
                     confidence: 0.0,
                     full_text: document.getElementById('inputText').value
                 });
                 
             } else {
                 // Handle existing correction feedback (original functionality)
                 if (!userCorrection) {
                     alert('Please enter a correction');
                     return;
                 }
                 
                 // Check if we have a valid correction object
                 const correction = window.currentBubbleCorrection || window.currentHoverCorrection;
                 if (!correction) {
                     console.error('No correction object available for feedback');
                     alert('Error: No correction data available. Please try again.');
                     return;
                 }
                 
                 console.log('User feedback data being sent:', {
                     original: correction.original,
                     aiSuggestion: correction.suggestion,
                     userCorrection: userCorrection,
                     correctionType: correction.type,
                     confidence: correction.confidence
                 });
                 
                 // Send negative feedback with user correction to backend
                 // Determine feedback type based on whether user provided a correction
                 const feedbackType = userCorrection.trim() ? 'manual_correction' : 'negative';
                 
                 sendFeedbackToAPI({
                     original: correction.original,
                     ai_suggestion: correction.suggestion,
                     user_correction: userCorrection,
                     feedback_type: feedbackType,
                     correction_type: correction.type || 'unknown',
                     confidence: correction.confidence || 0.5
                 });
                 
                 hideBubble();
             }
             
             closeModal();
         }

                 async function sendFeedbackToAPI(feedbackData) {
             try {
                 console.log('Sending feedback to API:', feedbackData);
                 
                 const response = await fetch('/demo/feedback', {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/json',
                     },
                     body: JSON.stringify(feedbackData)
                 });
                 
                 console.log('Feedback API response status:', response.status);
                 
                 if (response.ok) {
                     const result = await response.json();
                     console.log('Feedback sent successfully:', result);
                     
                     // Show success message briefly
                     const originalStatus = document.getElementById('statusText').textContent;
                     updateStatus('clean', '✅', 'Feedback sent - thank you!');
                     setTimeout(() => {
                         // Restore original status after 2 seconds
                         if (currentCorrections.length > 0) {
                             updateStatus('errors', '⚠️', `${currentCorrections.length} correction${currentCorrections.length > 1 ? 's' : ''} found`);
                         } else {
                             updateStatus('clean', '✅', 'Text looks great!');
                         }
                     }, 2000);
                 } else {
                     // Get error details
                     const errorText = await response.text();
                     console.error('Failed to send feedback. Status:', response.status, 'Error:', errorText);
                     
                     // Show error to user
                     updateStatus('ready', '⚠️', 'Failed to send feedback - please try again');
                     setTimeout(() => {
                         if (currentCorrections.length > 0) {
                             updateStatus('errors', '⚠️', `${currentCorrections.length} correction${currentCorrections.length > 1 ? 's' : ''} found`);
                         } else {
                             updateStatus('ready', '✏️', 'Ready to check your text');
                         }
                     }, 3000);
                 }
             } catch (error) {
                 console.error('Error sending feedback:', error);
                 
                 // Show error to user
                 updateStatus('ready', '⚠️', 'Network error - feedback not sent');
                 setTimeout(() => {
                     if (currentCorrections.length > 0) {
                         updateStatus('errors', '⚠️', `${currentCorrections.length} correction${currentCorrections.length > 1 ? 's' : ''} found`);
                     } else {
                         updateStatus('ready', '✏️', 'Ready to check your text');
                     }
                 }, 3000);
             }
         }

        function updateStatus(type, icon, text) {
            const statusIndicator = document.getElementById('statusIndicator');
            const statusIcon = document.getElementById('statusIcon');
            const statusText = document.getElementById('statusText');
            const statusFeedbackButtons = document.getElementById('statusFeedbackButtons');
            
            statusIndicator.className = 'status-indicator';
            statusIndicator.classList.add(`status-${type}`);
            
            statusIcon.textContent = icon;
            statusText.textContent = text;
            
            // Show feedback buttons only when text is clean (no corrections found)
            if (type === 'clean') {
                statusFeedbackButtons.style.display = 'flex';
            } else {
                statusFeedbackButtons.style.display = 'none';
            }
        }

        function clearTextStyling() {
            const inputText = document.getElementById('inputText');
            inputText.classList.remove('checking', 'has-errors', 'no-errors');
        }

        function initializeRealtimeChecking() {
            const inputText = document.getElementById('inputText');
            
            inputText.addEventListener('input', handleTextChange);
            inputText.addEventListener('paste', () => {
                setTimeout(handleTextChange, 100);
            });
            
            // Backup check every 3 seconds to catch any missed changes
            setInterval(() => {
                if (!isChecking) {
                    const currentText = inputText.value;
                    if (currentText.trim() && currentText.trim() !== lastCheckedText.trim()) {
                        console.log('Backup check detected unprocessed changes');
                        handleTextChange();
                    }
                }
            }, 3000);
            
            inputText.addEventListener('scroll', () => {
                const highlightedText = document.getElementById('highlightedText');
                if (highlightedText) {
                    highlightedText.scrollTop = inputText.scrollTop;
                    highlightedText.scrollLeft = inputText.scrollLeft;
                }
            });
            
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeModal();
                    hideBubble();
                }
            });
        }

        // Load a default example on page load
        window.onload = function() {
            initializeRealtimeChecking();
            loadExample('mixed');
        };
    </script>
</body>
</html> 